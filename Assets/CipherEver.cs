using KModkit;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Rnd = UnityEngine.Random;

public class CipherEver : MonoBehaviour
{

    public KMBombInfo Bomb;
    public KMAudio Audio;
    public KMBombModule module;

    static int ModuleIdCounter = 1;
    int ModuleId;
    private bool ModuleSolved;

    public KMSelectable[] keyboard;
    public TextMesh[] ScreenTexts;
    public KMSelectable left;
    public KMSelectable right;
    public KMSelectable submit;

    public GameObject subText;
    public GameObject TrainsImage;

    public Material BGMat;
    public Texture[] BackgroundImages;


    string[,] pageContents = new string[6, 3];


    bool moduleSolved;
    bool moduleSelected;

    bool pagesLocked = true;
    bool Submission = false;

    int routeStage = 1;

    int screenToWrite = 0;

    int currentPage = 0;
    int pages = 6;

    // Kuro variables
    TubeLine[] lines;
    TubeLine.Path[] linesTakenPathOne = new TubeLine.Path[2];
    TubeLine.Path[] linesTakenPathTwo = new TubeLine.Path[3];
    string origin;
    string destination;
    string[] routeInputs = new string[3];
    bool angelUnicorn;
    bool ikeaUnicorn;
    string angelUnicornSubmission;
    int tubecipherBackgroundNumber = 0;

    string[] six_letter_words = new string[]
            {
                "ABACUS", "ABDUCT", "ABJECT", "ABLAZE", "ABOARD", "ABOUND", "ABROAD", "ABRUPT", "ABSENT", "ABSORB", "ABSURD", "ABUSED", "ABUSER", "ABUSES", "ACACIA", "ACCEDE", "ACCENT", "ACCEPT", "ACCESS", "ACCORD", "ACCOST", "ACCRUE", "ACCUSE", "ACETIC", "ACHING", "ACIDIC", "ACQUIT", "ACROSS", "ACTING", "ACTION", "ACTIVE", "ACTORS", "ACTUAL", "ACUITY", "ACUMEN", "ADAGIO", "ADDICT", "ADDING", "ADHERE", "ADJOIN", "ADJUST", "ADMIRE", "ADMITS", "ADORED", "ADRIFT", "ADULTS", "ADVENT", "ADVERB", "ADVERT", "ADVICE", "ADVISE", "AERIAL", "AFFAIR", "AFFECT", "AFFINE", "AFFIRM", "AFFORD", "AFGHAN", "AFIELD", "AFLAME", "AFLOAT", "AFRAID", "AFRESH", "AFRICA", "AGENCY", "AGENDA", "AGENTS", "AGHAST", "AGREED", "AGREES", "AIMING", "AIRBAG", "AIRING", "ALASKA", "ALBEIT", "ALBINO", "ALBUMS", "ALCOVE", "ALIENS", "ALKALI", "ALLEGE", "ALLELE", "ALLIED", "ALLIES", "ALLOWS", "ALLUDE", "ALLURE", "ALMOND", "ALMOST", "ALPACA", "ALPINE", "ALUMNA", "ALUMNI", "ALWAYS", "AMAZED", "AMAZON", "AMBUSH", "AMENDS", "AMIDST", "AMOEBA", "AMORAL", "AMOUNT", "AMULET", "AMUSED", "ANALOG", "ANCHOR", "ANEMIA", "ANEMIC", "ANGELS", "ANGINA", "ANGLED", "ANGLER", "ANGLES", "ANGORA", "ANIMAL", "ANKLES", "ANKLET", "ANNUAL", "ANOINT", "ANORAK", "ANSWER", "ANTHEM", "ANTICS", "ANTLER", "ANYHOW", "ANYONE", "ANYWAY", "AORTIC", "APACHE", "APATHY", "APIECE", "APOGEE", "APPALL", "APPEAL", "APPEAR", "APPEND", "APPLES", "APPLET", "ARCADE", "ARCANA", "ARCANE", "ARCHED", "ARCHER", "ARCHES", "ARCHLY", "ARCTIC", "ARDENT", "ARGUED", "ARGUES", "ARISEN", "ARISES", "ARMADA", "ARMFUL", "ARMIES", "ARMING", "ARMORY", "ARMOUR", "ARMPIT", "AROUND", "AROUSE", "ARREST", "ARRIVE", "ARROWS", "ARTERY", "ARTFUL", "ARTIST", "ASCEND", "ASCENT", "ASHORE", "ASKING", "ASLEEP", "ASPECT", "ASPIRE", "ASSENT", "ASSERT", "ASSESS", "ASSETS", "ASSIGN", "ASSIST", "ASSUME", "ASSURE", "ASTHMA", "ASTRAL", "ASTRAY", "ASTUTE", "ASYLUM", "ATOMIC", "ATONAL", "ATRIUM", "ATTACH", "ATTACK", "ATTAIN", "ATTEND", "ATTEST", "ATTIRE", "ATTUNE", "AUGUST", "AUNTIE", "AUTHOR", "AUTISM", "AUTUMN", "AVATAR", "AVENGE", "AVENUE", "AVERSE", "AVIARY", "AVIDLY", "AVOIDS", "AVOWAL", "AVOWED", "AWAKEN", "AWARDS", "AWHILE", "AWNING", "AZALEA",
                "BABBLE", "BABIES", "BABOON", "BACKED", "BACKER", "BACKUP", "BADDIE", "BADGER", "BAFFLE", "BAGGED", "BAGGER", "BAGGIE", "BAITED", "BAKERY", "BAKING", "BALDLY", "BALLAD", "BALLET", "BALLOT", "BALSAM", "BAMBOO", "BANANA", "BANDED", "BANDIT", "BANGED", "BANGER", "BANISH", "BANKED", "BANKER", "BANNED", "BANNER", "BANTER", "BANZAI", "BAOBAB", "BARBED", "BARBER", "BARELY", "BARIUM", "BARKER", "BARLEY", "BARMAN", "BARNET", "BARONS", "BARRED", "BARREL", "BARREN", "BARTER", "BASALT", "BASICS", "BASINS", "BASKET", "BASQUE", "BASSET", "BATHER", "BATTEN", "BATTER", "BATTLE", "BAUBLE", "BAZAAR", "BEACON", "BEADED", "BEAGLE", "BEAKER", "BEAMED", "BEARER", "BEASTS", "BEATEN", "BEATER", "BEAUTY", "BEAVER", "BECAME", "BECKON", "BECOME", "BEDBUG", "BEDLAM", "BEDPAN", "BEEPER", "BEETLE", "BEFALL", "BEFORE", "BEGGAR", "BEGGED", "BEGINS", "BEHALF", "BEHAVE", "BEHEAD", "BEHEST", "BEHIND", "BEHOLD", "BEINGS", "BELIEF", "BELLOW", "BELONG", "BELTED", "BEMOAN", "BENIGN", "BERATE", "BEREFT", "BERLIN", "BESIDE", "BESTOW", "BETRAY", "BETTER", "BETTOR", "BEWARE", "BEYOND", "BIASED", "BICEPS", "BICKER", "BIDDER", "BIGGER", "BIGWIG", "BIKING", "BIKINI", "BILLOW", "BINARY", "BINDER", "BIOGAS", "BIONIC", "BIOPIC", "BIOPSY", "BIOTIC", "BIRDER", "BIRDIE", "BIRTHS", "BISECT", "BISHOP", "BISQUE", "BISTRO", "BITING", "BITTEN", "BITTER", "BLACKS", "BLADES", "BLAMED", "BLANCH", "BLASTS", "BLAZER", "BLEACH", "BLEARY", "BLIGHT", "BLITHE", "BLOCKS", "BLOCKY", "BLONDE", "BLOODY", "BLOTCH", "BLOUSE", "BLOWER", "BLUISH", "BLURRY", "BOARDS", "BOASTS", "BOBBLE", "BOBCAT", "BODEGA", "BODICE", "BODIES", "BODILY", "BOGGLE", "BOILED", "BOILER", "BOLDLY", "BOLERO", "BOLTED", "BOMBED", "BOMBER", "BONBON", "BONDED", "BONNET", "BONOBO", "BONSAI", "BOOGIE", "BOOKED", "BOOKIE", "BOOMER", "BOOTED", "BORDER", "BOREAL", "BORING", "BORROW", "BOSSES", "BOSTON", "BOTANY", "BOTHER", "BOTTLE", "BOTTOM", "BOUGHT", "BOUNCE", "BOUNCY", "BOUNDS", "BOUNTY", "BOVINE", "BOWING", "BOWLER", "BOWTIE", "BOXCAR", "BOXING", "BOYISH", "BRAINS", "BRAINY", "BRAISE", "BRAKES", "BRANCH", "BRANDS", "BRANDY", "BRASSY", "BRAWNY", "BRAZEN", "BRAZIL", "BREACH", "BREAKS", "BREAST", "BREATH", "BREECH", "BREEDS", "BREEZE", "BREEZY", "BRICKS", "BRIDAL", "BRIDGE", "BRIDLE", "BRIGHT", "BRINGS", "BROACH", "BROGUE", "BROKEN", "BROKER", "BRONZE", "BROOCH", "BROOKS", "BROWSE", "BRUISE", "BRUNCH", "BRUSHY", "BRUTAL", "BUBBLE", "BUBBLY", "BUCKET", "BUCKLE", "BUDGET", "BUFFED", "BUFFER", "BUFFET", "BUGGER", "BUILDS", "BULLET", "BUMBLE", "BUMMED", "BUMMER", "BUMPER", "BUNDLE", "BUNGEE", "BUNGLE", "BUNKER", "BURDEN", "BUREAU", "BURGER", "BURIAL", "BURIED", "BURLAP", "BURNED", "BURNER", "BURROW", "BURSTS", "BUSBOY", "BUSHEL", "BUSHES", "BUSILY", "BUSING", "BUSMAN", "BUSTED", "BUSTLE", "BUTANE", "BUTLER", "BUTTER", "BUTTON", "BUYERS", "BUYING", "BUYOUT", "BUZZER", "BYGONE", "BYPASS",
                "CABLES", "CACKLE", "CACTUS", "CAESAR", "CAIMAN", "CALICO", "CALLED", "CALLER", "CALLUS", "CALMLY", "CALVES", "CAMERA", "CAMPER", "CAMPUS", "CANADA", "CANALS", "CANARY", "CANCEL", "CANCER", "CANDID", "CANDLE", "CANDOR", "CANINE", "CANNED", "CANNON", "CANOLA", "CANOPY", "CANTER", "CANVAS", "CANYON", "CAPPED", "CAPTOR", "CARBON", "CAREEN", "CAREER", "CARERS", "CARESS", "CARING", "CARNAL", "CARPAL", "CARPET", "CARROT", "CARTEL", "CARTON", "CARVED", "CASEIN", "CASHEW", "CASING", "CASINO", "CASKET", "CASTER", "CASTLE", "CASUAL", "CATCHY", "CATION", "CATNAP", "CATNIP", "CATTLE", "CAUGHT", "CAUSAL", "CAUSED", "CAUSES", "CAVEAT", "CAVERN", "CAVIAR", "CAVING", "CAVITY", "CAVORT", "CEASED", "CELERY", "CELLAR", "CELTIC", "CEMENT", "CENSOR", "CENSUS", "CENTER", "CENTRE", "CEREAL", "CERVIX", "CESIUM", "CHAINS", "CHAIRS", "CHAISE", "CHAKRA", "CHALET", "CHALKY", "CHANCE", "CHANGE", "CHAPEL", "CHARGE", "CHARTS", "CHASER", "CHASTE", "CHATTY", "CHECKS", "CHEEKS", "CHEEKY", "CHEERS", "CHEERY", "CHEESE", "CHEESY", "CHEQUE", "CHERRY", "CHERUB", "CHEWED", "CHICKS", "CHIEFS", "CHILLY", "CHISEL", "CHIVES", "CHOICE", "CHOKED", "CHOKER", "CHOOSE", "CHOPPY", "CHORAL", "CHORDS", "CHORUS", "CHOSEN", "CHROME", "CHUBBY", "CHUNKS", "CHUNKY", "CHURCH", "CICADA", "CINDER", "CINEMA", "CIPHER", "CIRCLE", "CIRCUS", "CITIES", "CITING", "CITRUS", "CIVICS", "CLAIMS", "CLAMMY", "CLAMOR", "CLASSY", "CLAUSE", "CLAWED", "CLEAVE", "CLENCH", "CLERGY", "CLERIC", "CLERKS", "CLEVER", "CLICHE", "CLIENT", "CLIFFS", "CLIMAX", "CLINCH", "CLINGY", "CLINIC", "CLIQUE", "CLOCKS", "CLONED", "CLONES", "CLOSED", "CLOSER", "CLOSES", "CLOSET", "CLOTHE", "CLOUDS", "CLOUDY", "CLOVER", "CLUMPY", "CLUMSY", "CLUNKY", "CLUTCH", "COARSE", "COASTS", "COATED", "COBALT", "COBBLE", "COBWEB", "COCOON", "CODDLE", "CODIFY", "CODING", "COERCE", "COFFEE", "COFFER", "COFFIN", "COGNAC", "COHERE", "COHORT", "COILED", "COLDER", "COLDLY", "COLLAR", "COLONY", "COLORS", "COLUMN", "COMBAT", "COMEDY", "COMING", "COMMIT", "COMMON", "COMPEL", "COMPLY", "CONCUR", "CONDOR", "CONFER", "CONSUL", "CONVEX", "CONVEY", "CONVOY", "COOKED", "COOKER", "COOKIE", "COOLED", "COOLER", "COPIED", "COPIER", "COPIES", "COPING", "COPPER", "CORDED", "CORDON", "CORNEA", "CORNED", "CORNER", "CORNET", "CORONA", "CORPSE", "CORPUS", "CORRAL", "CORSET", "CORTEX", "COSMIC", "COSMOS", "COSTLY", "COTTON", "COUNTS", "COUNTY", "COUPLE", "COUPON", "COURSE", "COURTS", "COUSIN", "COVENT", "COVERS", "COVERT", "COWARD", "COWBOY", "COYOTE", "CRABBY", "CRACKS", "CRADLE", "CRAFTY", "CRANKY", "CRANNY", "CRATER", "CRAYON", "CRAZED", "CREAKY", "CREAMY", "CREASE", "CREATE", "CREDIT", "CREEPY", "CREOLE", "CRETIN", "CREWED", "CRIMES", "CRINGE", "CRISES", "CRISIS", "CRISPS", "CRISPY", "CRITIC", "CROCUS", "CROTCH", "CROUCH", "CROWDS", "CRUISE", "CRUMMY", "CRUNCH", "CRUSTY", "CRUTCH", "CRYING", "CUBISM", "CUBIST", "CUCKOO", "CUDDLE", "CUDDLY", "CUPPED", "CURATE", "CURDLE", "CURFEW", "CURLED", "CURLER", "CURSED", "CURSOR", "CURTLY", "CURTSY", "CURVED", "CURVES", "CUSTOM", "CUTESY", "CUTLET", "CUTTER", "CYBORG", "CYCLES", "CYCLIC", "CYMBAL", "CYSTIC",
                "DABBLE", "DAGGER", "DAIKON", "DAINTY", "DAMAGE", "DAMPEN", "DAMPER", "DAMSEL", "DANCED", "DANCER", "DANCES", "DANDER", "DANGER", "DANGLE", "DANISH", "DAPPER", "DAPPLE", "DARING", "DARKEN", "DARKER", "DARKLY", "DARNED", "DASHED", "DASHER", "DATING", "DAWDLE", "DAZZLE", "DEADEN", "DEADLY", "DEAFEN", "DEALER", "DEARLY", "DEATHS", "DEBASE", "DEBATE", "DEBRIS", "DEBTOR", "DEBUNK", "DECADE", "DECAMP", "DECANT", "DECEIT", "DECENT", "DECIDE", "DECODE", "DECREE", "DEDUCE", "DEDUCT", "DEEMED", "DEEPEN", "DEEPER", "DEEPLY", "DEFACE", "DEFAME", "DEFANG", "DEFEAT", "DEFECT", "DEFEND", "DEFILE", "DEFINE", "DEFORM", "DEFRAY", "DEFTLY", "DEFUSE", "DEGREE", "DELAYS", "DELETE", "DELUDE", "DELUGE", "DELUXE", "DEMAND", "DEMEAN", "DEMISE", "DEMONS", "DEMOTE", "DEMURE", "DENIAL", "DENIED", "DENIER", "DENIES", "DENOTE", "DENTAL", "DENTED", "DENUDE", "DEPART", "DEPEND", "DEPICT", "DEPLOY", "DEPORT", "DEPOSE", "DEPTHS", "DEPUTY", "DERAIL", "DERIDE", "DERIVE", "DERMAL", "DESERT", "DESIGN", "DESIRE", "DESIST", "DESPOT", "DETACH", "DETAIL", "DETAIN", "DETECT", "DETEST", "DETOUR", "DEVICE", "DEVILS", "DEVISE", "DEVOID", "DEVOTE", "DEVOUR", "DEVOUT", "DIADEM", "DIALOG", "DIAPER", "DIATOM", "DICTUM", "DIESEL", "DIFFER", "DIGEST", "DIGGER", "DIGITS", "DILATE", "DILUTE", "DIMMED", "DIMMER", "DIMPLE", "DINGHY", "DINING", "DINNER", "DIOXIN", "DIPOLE", "DIRECT", "DISARM", "DISBAR", "DISCUS", "DISHES", "DISMAL", "DISMAY", "DISOWN", "DISPEL", "DISUSE", "DITHER", "DIVERS", "DIVERT", "DIVEST", "DIVIDE", "DIVINE", "DIVING", "DOABLE", "DOCILE", "DOCKET", "DOCTOR", "DOGGIE", "DOINGS", "DOLLAR", "DOLLOP", "DOMAIN", "DOMINO", "DONATE", "DONKEY", "DONORS", "DOODAD", "DOODLE", "DOOMED", "DORSAL", "DOSAGE", "DOTING", "DOTTED", "DOUBLE", "DOUBLY", "DOUBTS", "DOUGHY", "DOVISH", "DOWNED", "DOWNER", "DOZENS", "DRAFTY", "DRAGON", "DRAINS", "DRAPED", "DRAWER", "DREAMS", "DREAMY", "DREARY", "DREDGE", "DRENCH", "DRESSY", "DRINKS", "DRIPPY", "DRIVEL", "DRIVEN", "DRIVER", "DRIVES", "DROOPY", "DROWSE", "DROWSY", "DRUDGE", "DRYING", "DUFFEL", "DUGOUT", "DULLED", "DUMBLY", "DUMPED", "DUPLEX", "DURESS", "DURIAN", "DURING", "DUSTER", "DUTIES", "DYEING", "DYNAMO",
                "EAGLES", "EARFUL", "EARNED", "EARNER", "EARTHY", "EASIER", "EASILY", "EASING", "EASTER", "EATERY", "EATING", "ECHOED", "ECHOES", "ECLAIR", "ECZEMA", "EDGING", "EDIBLE", "EDITED", "EDITOR", "EERILY", "EFFECT", "EFFIGY", "EFFORT", "EGGNOG", "EGOISM", "EGRESS", "EIGHTH", "EIGHTY", "EITHER", "ELAPSE", "ELATED", "ELBOWS", "ELDERS", "ELDEST", "ELEVEN", "ELICIT", "ELITES", "ELIXIR", "ELVISH", "EMBALM", "EMBARK", "EMBLEM", "EMBODY", "EMBOSS", "EMBRYO", "EMERGE", "EMPIRE", "EMPLOY", "ENABLE", "ENAMEL", "ENCASE", "ENCODE", "ENCORE", "ENDEAR", "ENDING", "ENDURE", "ENERGY", "ENFOLD", "ENGAGE", "ENGINE", "ENGULF", "ENIGMA", "ENJOIN", "ENJOYS", "ENLIST", "ENMITY", "ENOUGH", "ENRAGE", "ENRICH", "ENROLL", "ENSURE", "ENTAIL", "ENTERS", "ENTICE", "ENTIRE", "ENTITY", "ENTOMB", "ENTRAP", "ENTREE", "ENZYME", "EQUALS", "EQUATE", "EQUINE", "EQUITY", "ERASED", "ERASER", "ERODED", "ERRAND", "ERRANT", "ERRORS", "ERSATZ", "ESCAPE", "ESCHEW", "ESCORT", "ESSAYS", "ESTATE", "ESTEEM", "ETHICS", "ETHNIC", "EULOGY", "EUREKA", "EUROPE", "EVENLY", "EVENTS", "EVOLVE", "EXCEED", "EXCEPT", "EXCESS", "EXCISE", "EXCITE", "EXCUSE", "EXEMPT", "EXHALE", "EXHORT", "EXHUME", "EXILED", "EXISTS", "EXODUS", "EXOTIC", "EXPAND", "EXPECT", "EXPEND", "EXPERT", "EXPIRE", "EXPIRY", "EXPORT", "EXPOSE", "EXTANT", "EXTEND", "EXTENT", "EXTORT", "EXTRAS", "EYEFUL", "EYELID",
                "FABLED", "FABRIC", "FACADE", "FACETS", "FACIAL", "FACILE", "FACING", "FACTOR", "FADING", "FAILED", "FAIRLY", "FAKERY", "FAKING", "FALCON", "FALLEN", "FALTER", "FAMILY", "FAMINE", "FAMOUS", "FANDOM", "FARMED", "FARMER", "FASTEN", "FASTER", "FATHER", "FATHOM", "FATTEN", "FAUCET", "FAULTS", "FAULTY", "FAVOUR", "FEARED", "FEDORA", "FEEBLE", "FEEBLY", "FEEDER", "FEELER", "FEISTY", "FELINE", "FELLED", "FELLOW", "FELONY", "FEMALE", "FENCED", "FENCER", "FENCES", "FENDER", "FENNEL", "FERRET", "FESTER", "FETISH", "FETTER", "FEUDAL", "FIANCE", "FIASCO", "FIBRES", "FIBULA", "FICKLE", "FIDDLE", "FIDGET", "FIELDS", "FIERCE", "FIFTHS", "FIGHTS", "FIGURE", "FILIAL", "FILING", "FILLED", "FILLER", "FILLET", "FILMED", "FILTER", "FILTHY", "FINALE", "FINALS", "FINDER", "FINELY", "FINERY", "FINEST", "FINGER", "FINISH", "FINITE", "FIRING", "FIRMLY", "FISCAL", "FISHER", "FISTED", "FITTED", "FITTER", "FIXATE", "FIXING", "FIZZLE", "FLABBY", "FLAMES", "FLANKS", "FLARED", "FLASHY", "FLATLY", "FLAUNT", "FLAVOR", "FLAWED", "FLEECE", "FLESHY", "FLEXOR", "FLIGHT", "FLIMSY", "FLINCH", "FLIRTY", "FLOCKS", "FLOODS", "FLOORS", "FLOPPY", "FLORAL", "FLOWED", "FLOWER", "FLUENT", "FLUFFY", "FLUIDS", "FLURRY", "FLUTED", "FLYING", "FLYWAY", "FODDER", "FOETUS", "FOILED", "FOLDED", "FOLDER", "FOLLOW", "FONDLE", "FONDLY", "FONDUE", "FOODIE", "FOOTER", "FORAGE", "FORBID", "FORCED", "FORCES", "FOREGO", "FOREST", "FORGED", "FORGER", "FORGET", "FORGOT", "FORKED", "FORMAL", "FORMAT", "FORMED", "FORMER", "FOSSIL", "FOSTER", "FOUGHT", "FOULED", "FOURTH", "FOWLER", "FRAMED", "FRAMER", "FRAMES", "FRANCE", "FRANCO", "FRANCS", "FRAYED", "FREAKY", "FREELY", "FREEZE", "FRENCH", "FRENZY", "FRESCO", "FRIDAY", "FRIDGE", "FRIEND", "FRIGHT", "FRIGID", "FRILLY", "FRINGE", "FRISKY", "FRIZZY", "FROLIC", "FRONTS", "FROSTY", "FROTHY", "FROZEN", "FRUGAL", "FRUITS", "FRUITY", "FRYING", "FUELED", "FULFIL", "FULHAM", "FULLER", "FUMBLE", "FUNDED", "FUNDER", "FUNGAL", "FUNGUS", "FUNNEL", "FURROW", "FUSION", "FUTILE", "FUTURE",
                "GADFLY", "GADGET", "GAELIC", "GAFFER", "GAGGLE", "GAIETY", "GAINED", "GAINER", "GALAXY", "GALLEY", "GALLON", "GALLOP", "GALORE", "GAMBIT", "GAMBLE", "GAMELY", "GAMETE", "GAMING", "GANDER", "GANGLY", "GANTRY", "GAPING", "GARAGE", "GARBLE", "GARDEN", "GARGLE", "GARISH", "GARLIC", "GARNER", "GARNET", "GASKET", "GASPED", "GATHER", "GAZEBO", "GAZING", "GEARED", "GEEZER", "GEISHA", "GELATO", "GENDER", "GENEVA", "GENIAL", "GENIUS", "GENOME", "GENTLE", "GENTLY", "GENTRY", "GERBIL", "GERMAN", "GETTER", "GEYSER", "GHETTO", "GHOSTS", "GIANTS", "GIBLET", "GIFTED", "GIGGLE", "GILDED", "GINGER", "GIRDER", "GIRDLE", "GIRLIE", "GIVING", "GLADLY", "GLANCE", "GLANDS", "GLARED", "GLASSY", "GLAZED", "GLIDER", "GLITCH", "GLOBAL", "GLOOMY", "GLOSSY", "GLOVED", "GLOVES", "GLOWER", "GLUMLY", "GLUTEN", "GLYCOL", "GNARLY", "GOALIE", "GOATEE", "GOBBLE", "GOBLET", "GOBLIN", "GOGGLE", "GOLDEN", "GOLFER", "GOODLY", "GOPHER", "GOSPEL", "GOSSIP", "GOTHIC", "GOTTEN", "GOVERN", "GRADED", "GRADER", "GRADES", "GRAHAM", "GRAINS", "GRAINY", "GRANNY", "GRANTS", "GRAPES", "GRAPHS", "GRASSY", "GRATED", "GRATER", "GRAVEL", "GRAVEN", "GRAVES", "GRAZED", "GREASE", "GREASY", "GREECE", "GREEDY", "GREENS", "GRIEVE", "GRILLE", "GRIMLY", "GRINCH", "GRISLY", "GRITTY", "GROCER", "GROGGY", "GROOVE", "GROOVY", "GROTTO", "GROUCH", "GROUND", "GROUPS", "GROVEL", "GROWER", "GROWTH", "GRUBBY", "GRUDGE", "GRUMPY", "GRUNGE", "GRUNGY", "GUARDS", "GUESTS", "GUIDED", "GUIDES", "GUILTY", "GUINEA", "GUITAR", "GULLET", "GUNMAN", "GUNMEN", "GUNNER", "GURGLE", "GURNEY", "GUSHER", "GUTTED", "GUTTER", "GUZZLE", "GYPSUM", "GYRATE",
                "HABITS", "HACKER", "HADRON", "HAGGIS", "HAGGLE", "HAIRDO", "HALTED", "HALTER", "HALVED", "HALVES", "HAMLET", "HAMMER", "HAMPER", "HANDED", "HANDLE", "HANGAR", "HANGER", "HANKER", "HAPPEN", "HARASS", "HARBOR", "HARDEN", "HARDER", "HARDLY", "HARROW", "HASSLE", "HASTEN", "HATRED", "HAULED", "HAULER", "HAVING", "HAZARD", "HAZING", "HEADED", "HEADER", "HEALED", "HEALER", "HEALTH", "HEARER", "HEARSE", "HEARTH", "HEARTS", "HEARTY", "HEATED", "HEATER", "HEAVED", "HEAVEN", "HECKLE", "HECTIC", "HEDGES", "HEIGHT", "HELIUM", "HELMET", "HELPED", "HELPER", "HERALD", "HERBAL", "HERDER", "HEREBY", "HEREIN", "HERESY", "HERMIT", "HERNIA", "HEROES", "HEROIC", "HEYDAY", "HIATUS", "HICCUP", "HIDDEN", "HIDING", "HIGHER", "HIGHLY", "HIJACK", "HIKING", "HINDER", "HINGED", "HINGES", "HIPPIE", "HIRING", "HISSED", "HITHER", "HITMAN", "HITTER", "HOARSE", "HOBBIT", "HOBBLE", "HOBNOB", "HOCKEY", "HOLDER", "HOLDUP", "HOLLER", "HOLLOW", "HOMAGE", "HOMELY", "HOMING", "HONCHO", "HONEST", "HONOUR", "HOODED", "HOODIE", "HOOKED", "HOOKUP", "HOOPER", "HOOPLA", "HOORAY", "HOOVES", "HOPING", "HOPPER", "HORNED", "HORRID", "HORROR", "HORSES", "HORSEY", "HOSTEL", "HOTBED", "HOTDOG", "HOTELS", "HOTTIE", "HOUNDS", "HOURLY", "HOUSED", "HOUSES", "HOWLER", "HUBBUB", "HUBRIS", "HUDDLE", "HUGELY", "HUGGED", "HUGGER", "HUMANE", "HUMANS", "HUMBLE", "HUMBLY", "HUMBUG", "HUMMER", "HUMMUS", "HUMOUR", "HUMPED", "HUNGER", "HUNGRY", "HUNKER", "HUNTED", "HUNTER", "HURDLE", "HURRAH", "HUSHED", "HUSTLE", "HYBRID", "HYMNAL", "HYPHEN",
                "IAMBIC", "ICEBOX", "ICECAP", "ICICLE", "ICONIC", "IDEALS", "IDIOCY", "IDLING", "IGNITE", "IGNORE", "IGUANA", "IMAGES", "IMBIBE", "IMMUNE", "IMPACT", "IMPAIR", "IMPALE", "IMPART", "IMPEDE", "IMPISH", "IMPORT", "IMPOSE", "IMPROV", "IMPURE", "INCEST", "INCHES", "INCITE", "INCOME", "INDEED", "INDENT", "INDIAN", "INDICT", "INDIES", "INDIGO", "INDIUM", "INDOOR", "INDUCE", "INDUCT", "INFAMY", "INFANT", "INFECT", "INFEST", "INFILL", "INFIRM", "INFLOW", "INFLUX", "INFORM", "INFUSE", "INGEST", "INHALE", "INJECT", "INJURE", "INJURY", "INKPOT", "INLAND", "INMATE", "INNATE", "INNING", "INPUTS", "INSANE", "INSECT", "INSERT", "INSIDE", "INSIST", "INSTEP", "INSTIL", "INSULT", "INSURE", "INTACT", "INTAKE", "INTEND", "INTENT", "INTERN", "INTUIT", "INVADE", "INVENT", "INVERT", "INVEST", "INVITE", "INVOKE", "INWARD", "IODIDE", "IODINE", "IONIZE", "IRONED", "IRONIC", "ISLAND", "ISRAEL", "ISSUED", "ISSUER", "ISSUES", "ITSELF",
                "JABBER", "JACKAL", "JACKED", "JACKER", "JACKET", "JAGGED", "JAGUAR", "JAILED", "JAILER", "JAILOR", "JAMMED", "JAMMER", "JANGLE", "JANGLY", "JARGON", "JARRED", "JASPER", "JAZZED", "JERKED", "JERSEY", "JESTER", "JETLAG", "JETWAY", "JEWELS", "JEWISH", "JICAMA", "JIGGLE", "JIGSAW", "JINGLE", "JINGLY", "JINXED", "JINXES", "JIVING", "JOCKEY", "JOGGER", "JOINED", "JOINER", "JOINTS", "JOKERS", "JOKILY", "JOKING", "JOSTLE", "JOULES", "JOVIAL", "JOYFUL", "JOYOUS", "JUDGED", "JUDGER", "JUDGES", "JUGGLE", "JUICED", "JUICER", "JUICES", "JUMBLE", "JUMPED", "JUMPER", "JUNGLE", "JUNIOR", "JUNKER", "JUNKIE", "JURIED", "JURIES", "JURORS", "JUSTLY",
                "KABOOM", "KARATE", "KARMIC", "KAZOOS", "KEELED", "KEENLY", "KEEPER", "KELVIN", "KENNEL", "KERNEL", "KETTLE", "KEYPAD", "KHAKIS", "KIBBLE", "KICKED", "KICKER", "KIDDIE", "KIDNAP", "KIDNEY", "KILLED", "KILLER", "KIMONO", "KINDLE", "KINDLY", "KINGLY", "KIPPER", "KISSED", "KISSER", "KISSES", "KITSCH", "KITTEN", "KLAXON", "KNIGHT", "KNIVES", "KNOCKS", "KNOTTY", "KNOWER", "KOREAN", "KOSHER", "KRAKEN",
                "LABELS", "LABOUR", "LACKED", "LACKEY", "LACTIC", "LADDER", "LADDIE", "LADIES", "LAGGED", "LAGOON", "LAMBDA", "LAMELY", "LAMENT", "LANCER", "LANDED", "LAPDOG", "LAPSED", "LAPTOP", "LARDER", "LARGER", "LARVAE", "LASERS", "LASHES", "LASTED", "LASTLY", "LATELY", "LATENT", "LATEST", "LATHER", "LATTER", "LAUDED", "LAUGHS", "LAUNCH", "LAVISH", "LAWFUL", "LAWMAN", "LAWYER", "LAYERS", "LAYING", "LAYMAN", "LAYOFF", "LAYOUT", "LAZILY", "LAZULI", "LEADED", "LEADER", "LEAGUE", "LEAKED", "LEAKER", "LEANED", "LEAPER", "LEARNS", "LEARNT", "LEASED", "LEASES", "LEAVEN", "LEAVER", "LEAVES", "LECTOR", "LEDGER", "LEEWAY", "LEGACY", "LEGATE", "LEGATO", "LEGEND", "LEGGED", "LEGION", "LEGUME", "LEMONY", "LENDER", "LENGTH", "LENSES", "LESION", "LESSEN", "LESSER", "LESSON", "LETHAL", "LETTER", "LEVELS", "LEVITY", "LIABLE", "LIBIDO", "LICHEN", "LICKED", "LIDDED", "LIFTED", "LIFTER", "LIGHTS", "LIKELY", "LIKING", "LIMBER", "LIMBIC", "LIMITS", "LIMPLY", "LINEAR", "LINEUP", "LINGER", "LINING", "LINKED", "LIQUID", "LIQUOR", "LISTED", "LISTEN", "LITANY", "LITMUS", "LITRES", "LITTER", "LITTLE", "LIVELY", "LIVERY", "LIVING", "LIZARD", "LOADED", "LOADER", "LOAFER", "LOANED", "LOANER", "LOATHE", "LOCALE", "LOCALS", "LOCATE", "LOCKED", "LOCKER", "LOCKET", "LOCKUP", "LOCUST", "LODGED", "LODGER", "LOGGER", "LOITER", "LONDON", "LONELY", "LONGED", "LONGER", "LOOKED", "LOOKER", "LOOKUP", "LOOPED", "LOOSEN", "LOOTED", "LOOTER", "LORDLY", "LOSERS", "LOSING", "LOSSES", "LOTION", "LOUDER", "LOUDLY", "LOUNGE", "LOVELY", "LOVERS", "LOVING", "LOWEST", "LUGGED", "LUMBAR", "LUMBER", "LUNACY", "LUPINE", "LUSTER", "LUXURY", "LYCHEE", "LYRICS",
                "MADAME", "MADDEN", "MADMAN", "MAGGOT", "MAGNET", "MAGPIE", "MAIDEN", "MAILED", "MAILER", "MAIMED", "MAINLY", "MAKERS", "MAKEUP", "MAKING", "MALADY", "MALICE", "MALIGN", "MALLET", "MALTED", "MAMMAL", "MANAGE", "MANGER", "MANGLE", "MANIAC", "MANNED", "MANNER", "MANTIS", "MANTLE", "MANTRA", "MANUAL", "MANURE", "MARACA", "MARBLE", "MARCEL", "MARGIN", "MARINE", "MARKED", "MARKER", "MARKET", "MARKUP", "MARMOT", "MAROON", "MARROW", "MARSHY", "MARTIN", "MARTYR", "MARVEL", "MASCOT", "MASHED", "MASHER", "MASKED", "MASQUE", "MASSES", "MASSIF", "MASTER", "MATING", "MATRIX", "MATRON", "MATTED", "MATTER", "MATURE", "MAYDAY", "MAYFLY", "MAYHEM", "MEADOW", "MEAGER", "MEASLY", "MEDALS", "MEDDLE", "MEDIAN", "MEDIUM", "MEDLEY", "MEEKLY", "MELLOW", "MELODY", "MELTED", "MEMBER", "MEMOIR", "MEMORY", "MENACE", "MENIAL", "MENTAL", "MENTEE", "MENTOR", "MERELY", "MERGED", "MERGER", "MERITS", "MERLOT", "METALS", "METEOR", "METHOD", "METHYL", "METRES", "METRIC", "METTLE", "MEXICO", "MIASMA", "MICRON", "MIDDAY", "MIDDLE", "MIDGET", "MIDWAY", "MIGHTY", "MIGNON", "MILADY", "MILDEW", "MILDLY", "MILLED", "MILLER", "MIMOSA", "MINCED", "MINDED", "MINERS", "MINGLE", "MINING", "MINION", "MINNOW", "MINUET", "MINUTE", "MIRAGE", "MIRROR", "MISERY", "MISFIT", "MISHAP", "MISLED", "MISSED", "MISSES", "MISSUS", "MISTER", "MISUSE", "MITTEN", "MIXING", "MOANED", "MOBILE", "MODELS", "MODERN", "MODEST", "MODIFY", "MODULE", "MODULO", "MOLDED", "MOLDER", "MOLTEN", "MOMENT", "MONDAY", "MONGOL", "MONIES", "MONKEY", "MONTHS", "MORALE", "MORALS", "MORBID", "MORGAN", "MORGUE", "MORMON", "MORSEL", "MORTAL", "MORTAR", "MOSAIC", "MOSQUE", "MOSTLY", "MOTHER", "MOTIFS", "MOTION", "MOTIVE", "MOTLEY", "MOTORS", "MOUSSE", "MOUTHS", "MOVIES", "MOVING", "MUDDLE", "MUFFIN", "MUFFLE", "MUGGER", "MULLET", "MUMBLE", "MURDER", "MURMUR", "MURPHY", "MUSCLE", "MUSEUM", "MUSING", "MUSKET", "MUSTER", "MUTANT", "MUTATE", "MUTELY", "MUTINY", "MUTTER", "MUTTON", "MUTUAL", "MUZZLE", "MYOPIC", "MYRIAD", "MYSELF", "MYSTIC", "MYTHIC", "MYTHOS",
                "NAMELY", "NAMING", "NAPALM", "NAPKIN", "NARROW", "NATION", "NATIVE", "NATURE", "NAUGHT", "NAUSEA", "NEARBY", "NEARER", "NEARLY", "NEATLY", "NEBULA", "NECTAR", "NEEDED", "NEEDLE", "NEGATE", "NELSON", "NEPHEW", "NERVES", "NESTED", "NESTER", "NESTLE", "NETHER", "NETTLE", "NEURAL", "NEURON", "NEUTER", "NEWBIE", "NEWEST", "NEWISH", "NEWTON", "NIBBLE", "NICELY", "NICEST", "NICKEL", "NIGHTS", "NIMBLE", "NIMBLY", "NIMBUS", "NINETY", "NINJAS", "NIPPLE", "NITRIC", "NITWIT", "NOBLES", "NOBODY", "NODDED", "NODULE", "NOGGIN", "NOISES", "NOODLE", "NORDIC", "NORMAL", "NORMAN", "NOSIER", "NOSILY", "NOTARY", "NOTATE", "NOTICE", "NOTIFY", "NOTING", "NOTION", "NOUGHT", "NOVELS", "NOVICE", "NOZZLE", "NUANCE", "NUBILE", "NUCLEI", "NUDGER", "NUDGES", "NUDIST", "NUDITY", "NUGGET", "NUMBED", "NUMBER", "NUMBLY", "NURSED", "NURSES", "NUTMEG", "NUZZLE",
                "OBEYED", "OBJECT", "OBLIGE", "OBLONG", "OBOIST", "OBSESS", "OBTAIN", "OBTUSE", "OCCULT", "OCCUPY", "OCCURS", "OCEANS", "OCELOT", "OCTANE", "OCTAVE", "OCULAR", "OCULUS", "ODDITY", "OFFEND", "OFFERS", "OFFICE", "OFFSET", "OILMAN", "OLDEST", "OLIVES", "OMELET", "ONIONS", "ONLINE", "ONWARD", "OOZING", "OPAQUE", "OPENED", "OPENER", "OPENLY", "OPERAS", "OPIATE", "OPIOID", "OPPOSE", "OPTICS", "OPTING", "OPTION", "ORACLE", "ORALLY", "ORANGE", "ORATOR", "ORCHID", "ORDAIN", "ORDEAL", "ORDERS", "ORGANS", "ORIENT", "ORIGIN", "ORNATE", "ORPHAN", "OSMIUM", "OTHERS", "OUNCES", "OUSTED", "OUSTER", "OUTAGE", "OUTBID", "OUTCRY", "OUTDID", "OUTFIT", "OUTFOX", "OUTING", "OUTLAW", "OUTLET", "OUTPUT", "OUTRUN", "OUTSET", "OUTWIT", "OVERDO", "OVERLY", "OWLISH", "OWNERS", "OWNING", "OXFORD", "OXTAIL", "OXYGEN", "OYSTER",
                "PACIFY", "PACING", "PACKED", "PACKET", "PADDED", "PADDLE", "PAELLA", "PAGING", "PAGODA", "PAINED", "PAIRED", "PALACE", "PALATE", "PALLET", "PALLOR", "PALTRY", "PAMPER", "PANAMA", "PANDER", "PANELS", "PANTRY", "PAPACY", "PAPAYA", "PAPERS", "PAPERY", "PARADE", "PARCEL", "PARDON", "PARENT", "PARIAH", "PARING", "PARITY", "PARKED", "PARLAY", "PARLOR", "PARODY", "PAROLE", "PARROT", "PARSEC", "PARSON", "PARTED", "PARTLY", "PASSED", "PASSER", "PASSES", "PASTEL", "PASTOR", "PASTRY", "PATCHY", "PATENT", "PATHOS", "PATROL", "PATRON", "PATTED", "PATTEN", "PAUNCH", "PAUPER", "PAUSED", "PAVING", "PAYDAY", "PAYERS", "PAYING", "PAYOFF", "PAYOUT", "PEACHY", "PEAKED", "PEANUT", "PEARCE", "PEARLS", "PEARLY", "PEBBLE", "PECKER", "PECTIN", "PEDANT", "PEDDLE", "PEELED", "PEELER", "PEEPER", "PEERED", "PEEVED", "PELLET", "PELVIC", "PELVIS", "PENCIL", "PEOPLE", "PEPPER", "PEPTIC", "PERIOD", "PERISH", "PERMIT", "PERSON", "PERUSE", "PESTER", "PESTLE", "PETALS", "PETITE", "PETROL", "PEWTER", "PHARMA", "PHASED", "PHASES", "PHENOL", "PHLEGM", "PHOBIA", "PHOBIC", "PHONED", "PHONES", "PHONEY", "PHOTON", "PHOTOS", "PHRASE", "PICKED", "PICKER", "PICKET", "PICKLE", "PICKUP", "PICNIC", "PIDGIN", "PIECES", "PIERCE", "PIGEON", "PIGLET", "PIGPEN", "PIGSTY", "PILEUP", "PILFER", "PILLAR", "PILLOW", "PILOTS", "PIMPLE", "PINATA", "PINCER", "PINKIE", "PINNED", "PIPING", "PIRACY", "PIRATE", "PISSED", "PISTOL", "PITTED", "PIZAZZ", "PLACED", "PLACER", "PLACES", "PLACID", "PLAGUE", "PLAINS", "PLANAR", "PLANES", "PLANET", "PLANTS", "PLAQUE", "PLASMA", "PLATES", "PLAYED", "PLAYER", "PLEASE", "PLEDGE", "PLENTY", "PLEXUS", "PLIANT", "PLIERS", "PLIGHT", "PLOUGH", "PLOWED", "PLUNGE", "PLURAL", "POCKET", "PODIUM", "POETIC", "POETRY", "POINTS", "POINTY", "POISED", "POISON", "POLICE", "POLICY", "POLISH", "POLITE", "POLLEN", "POMMEL", "PONCHO", "PONDER", "PONIES", "POODLE", "POOLED", "POORER", "POORLY", "POPLAR", "POPPED", "POPPER", "POROUS", "PORTAL", "PORTER", "POSING", "POSSUM", "POSTAL", "POSTED", "POSTER", "POTATO", "POTENT", "POTION", "POTTED", "POTTER", "POUNCE", "POUNDS", "POURED", "POWDER", "POWERS", "PRAISE", "PRANCE", "PRAXIS", "PRAYED", "PRAYER", "PREACH", "PREFAB", "PREFER", "PREFIX", "PRESET", "PRESTO", "PRETTY", "PRICED", "PRICES", "PRICEY", "PRIEST", "PRIMAL", "PRIMED", "PRIMER", "PRIMLY", "PRINCE", "PRINTS", "PRIORY", "PRISON", "PRISSY", "PRIVET", "PRIZED", "PRIZES", "PROBES", "PROFIT", "PROMPT", "PROPEL", "PROPER", "PROTON", "PROVED", "PROVEN", "PROVES", "PRYING", "PSEUDO", "PSYCHE", "PSYCHO", "PUBLIC", "PUCKER", "PUDDLE", "PUEBLO", "PUFFED", "PUFFIN", "PULLED", "PULLER", "PULLEY", "PULPIT", "PULSAR", "PULSED", "PULSES", "PUMICE", "PUMMEL", "PUMPED", "PUMPER", "PUNDIT", "PUNISH", "PUPILS", "PUPPET", "PURELY", "PURIFY", "PURIST", "PURITY", "PURPLE", "PURSUE", "PUSHED", "PUSHER", "PUTRID", "PUTTER", "PUZZLE", "PYTHON",
                "QUACKS", "QUAILS", "QUAINT", "QUAKER", "QUALMS", "QUARKS", "QUARRY", "QUARTZ", "QUASAR", "QUAVER", "QUEASY", "QUEBEC", "QUEENS", "QUENCH", "QUEUED", "QUEUES", "QUICHE", "QUILLS", "QUINCE", "QUINOA", "QUIRKS", "QUIRKY", "QUIVER", "QUORUM", "QUOTAS", "QUOTED", "QUOTER", "QUOTES",
                "RABBIT", "RABBLE", "RABIES", "RACIAL", "RACING", "RACKET", "RADIAL", "RADIAN", "RADIOS", "RADISH", "RADIUM", "RADIUS", "RAFFLE", "RAFTER", "RAGGED", "RAGING", "RAGTAG", "RAISED", "RAISES", "RAISIN", "RAKING", "RAMBLE", "RANCID", "RANCOR", "RANDOM", "RANGED", "RANGES", "RANKED", "RANSOM", "RAPIER", "RAPPEL", "RAPPER", "RAPTOR", "RARELY", "RARITY", "RASCAL", "RASHES", "RATHER", "RATIFY", "RATING", "RATION", "RATIOS", "RATTLE", "RAVINE", "RAVING", "RAVISH", "READER", "REALLY", "REAPER", "REASON", "REBELS", "REBOOT", "REBORN", "REBUFF", "REBUKE", "RECALL", "RECANT", "RECAST", "RECEDE", "RECENT", "RECESS", "RECIPE", "RECITE", "RECKON", "RECODE", "RECOIL", "RECORD", "RECTAL", "RECTUM", "RECUSE", "REDDEN", "REDEEM", "REDIAL", "REDRAW", "REDUCE", "REFERS", "REFILL", "REFINE", "REFLEX", "REFLUX", "REFORM", "REFUEL", "REFUGE", "REFUND", "REFUSE", "REFUTE", "REGAIN", "REGALE", "REGARD", "REGENT", "REGGAE", "REGIME", "REGION", "REGRET", "REGROW", "REHASH", "REHEAT", "REJECT", "REJOIN", "RELATE", "RELENT", "RELICS", "RELIED", "RELIEF", "RELIES", "RELISH", "RELIVE", "RELOAD", "REMAIN", "REMAKE", "REMARK", "REMEDY", "REMIND", "REMISS", "REMOTE", "REMOVE", "RENAME", "RENDER", "RENEGE", "RENOWN", "RENTAL", "RENTED", "RENTER", "REOPEN", "REPAIR", "REPEAL", "REPEAT", "REPENT", "REPLAY", "REPORT", "REPOSE", "REPUTE", "REREAD", "RESCUE", "RESEAL", "RESENT", "RESIDE", "RESIGN", "RESIST", "RESIZE", "RESORT", "RESTED", "RESULT", "RESUME", "RETAIL", "RETAIN", "RETAKE", "RETEST", "RETINA", "RETIRE", "RETORT", "RETURN", "REVAMP", "REVEAL", "REVERB", "REVERE", "REVERT", "REVIEW", "REVILE", "REVISE", "REVIVE", "REVOKE", "REVOLT", "REWARD", "REWIND", "REWIRE", "REWORK", "RHESUS", "RHUMBA", "RHYTHM", "RIBALD", "RIBBED", "RIBBON", "RICHER", "RICHES", "RICHLY", "RIDDEN", "RIDDLE", "RIDERS", "RIDGED", "RIDGES", "RIDING", "RIFLES", "RIGGED", "RIGGER", "RIGHTS", "RIMMED", "RINGED", "RINGER", "RINSED", "RIOTER", "RIPPED", "RIPPER", "RIPPLE", "RISING", "RISQUE", "RITUAL", "RIVALS", "RIVERS", "ROADIE", "ROARED", "ROBBER", "ROBOTS", "ROBUST", "ROCKER", "ROCKET", "ROCOCO", "RODENT", "ROLLED", "ROLLER", "ROMANS", "ROOKIE", "ROOMIE", "ROOTED", "ROPING", "ROSARY", "ROSTER", "ROTARY", "ROTATE", "ROTTED", "ROTTEN", "ROTUND", "ROUNDS", "ROUTER", "ROUTES", "ROVERS", "ROVING", "ROWING", "RUBBED", "RUBBER", "RUBBLE", "RUBRIC", "RUCKUS", "RUDDER", "RUDELY", "RUDEST", "RUEFUL", "RUFFLE", "RUGGED", "RUINED", "RULERS", "RULING", "RUMBLE", "RUMOUR", "RUMPLE", "RUNNER", "RUNOFF", "RUNWAY", "RUSHED", "RUSHER", "RUSSIA", "RUSTED", "RUSTIC", "RUSTLE", "RUTTED",
                "SACKED", "SACRED", "SADDEN", "SADDLE", "SADISM", "SADIST", "SAFARI", "SAFELY", "SAFEST", "SAFETY", "SAGELY", "SAILED", "SAILOR", "SAINTS", "SALADS", "SALAMI", "SALARY", "SALINE", "SALIVA", "SALMON", "SALOON", "SALTED", "SALUTE", "SAMPLE", "SANDAL", "SANITY", "SAPPER", "SARONG", "SASHAY", "SATIRE", "SAUCER", "SAUTED", "SAVAGE", "SAVANT", "SAVING", "SAVIOR", "SAVORY", "SAWING", "SAYING", "SCALAR", "SCALED", "SCALES", "SCANTY", "SCARAB", "SCARCE", "SCARED", "SCENES", "SCENIC", "SCHEMA", "SCHEME", "SCHISM", "SCHOOL", "SCONCE", "SCORCH", "SCORED", "SCORER", "SCORES", "SCOTCH", "SCOUTS", "SCRAPE", "SCRAPS", "SCRAWL", "SCREAM", "SCREEN", "SCREWS", "SCREWY", "SCRIBE", "SCRIPT", "SCROLL", "SCRUFF", "SCULPT", "SCURRY", "SCURVY", "SCYTHE", "SEABED", "SEALED", "SEALER", "SEAMAN", "SEAMEN", "SEANCE", "SEARCH", "SEARED", "SEASON", "SEATED", "SECEDE", "SECOND", "SECRET", "SECTOR", "SECURE", "SEDATE", "SEDUCE", "SEEDED", "SEEING", "SEEKER", "SEEMED", "SEEMLY", "SEESAW", "SEETHE", "SEIZED", "SELDOM", "SELECT", "SELLER", "SENATE", "SENDER", "SENILE", "SENIOR", "SENSED", "SENSES", "SENSOR", "SENTRY", "SEPSIS", "SEPTAL", "SEPTET", "SEPTIC", "SEPTUM", "SEQUEL", "SEQUIN", "SERAPH", "SERENE", "SERIAL", "SERIES", "SERMON", "SERVED", "SERVER", "SERVES", "SESAME", "SETTEE", "SETTLE", "SEVENS", "SEVERE", "SEWAGE", "SEWING", "SEXTET", "SEXUAL", "SHABBY", "SHADED", "SHADES", "SHADOW", "SHAFTS", "SHAGGY", "SHAKEN", "SHAKER", "SHAMAN", "SHANTY", "SHAPED", "SHAPES", "SHARED", "SHARES", "SHAVED", "SHAVEN", "SHEARS", "SHEATH", "SHEETS", "SHEILA", "SHEKEL", "SHELLS", "SHELVE", "SHERRY", "SHIELD", "SHIFTS", "SHIFTY", "SHIMMY", "SHINER", "SHIRTS", "SHIVER", "SHOCKS", "SHODDY", "SHOGUN", "SHORES", "SHORTS", "SHOULD", "SHOUTS", "SHOVEL", "SHOWED", "SHOWER", "SHREWD", "SHRIEK", "SHRILL", "SHRIMP", "SHRINE", "SHRINK", "SHROUD", "SHRUBS", "SHTICK", "SHUCKS", "SICKEN", "SICKLE", "SICKLY", "SIDING", "SIENNA", "SIERRA", "SIESTA", "SIFTED", "SIFTER", "SIGHED", "SIGHTS", "SIGNAL", "SIGNED", "SIGNER", "SILENT", "SILKEN", "SILVER", "SIMIAN", "SIMILE", "SIMMER", "SIMPLE", "SIMPLY", "SINFUL", "SINGED", "SINGER", "SINGLE", "SINKER", "SINNER", "SIPHON", "SIPPED", "SISTER", "SITCOM", "SITTER", "SIZING", "SIZZLE", "SKATER", "SKETCH", "SKEWED", "SKEWER", "SKIING", "SKILLS", "SKIMPY", "SKINNY", "SKIRTS", "SKYBOX", "SLALOM", "SLATER", "SLAVES", "SLAYER", "SLEAZE", "SLEAZY", "SLEDGE", "SLEEPY", "SLEEVE", "SLEIGH", "SLEUTH", "SLICED", "SLICER", "SLICES", "SLIDER", "SLIDES", "SLIGHT", "SLINKY", "SLIVER", "SLOGAN", "SLOPED", "SLOPES", "SLOPPY", "SLOUCH", "SLOUGH", "SLOWED", "SLOWER", "SLOWLY", "SLUDGE", "SLURRY", "SLUSHY", "SMARMY", "SMARTS", "SMELLS", "SMELLY", "SMILED", "SMILES", "SMITHY", "SMOKED", "SMOKER", "SMOOCH", "SMOOTH", "SMUDGE", "SMUGLY", "SNAKES", "SNAPPY", "SNARKY", "SNATCH", "SNAZZY", "SNEAKY", "SNEEZE", "SNIPER", "SNIPPY", "SNITCH", "SNOBBY", "SNOOPY", "SNOOTY", "SNOOZE", "SNUGLY", "SOAKED", "SOAKER", "SOCCER", "SOCIAL", "SOCKET", "SODDEN", "SODIUM", "SODOMY", "SOFTEN", "SOFTER", "SOFTIE", "SOFTLY", "SOILED", "SOIREE", "SOLACE", "SOLDER", "SOLELY", "SOLEMN", "SOLIDS", "SOLVED", "SOLVER", "SOMBER", "SOMBRE", "SONATA", "SONNET", "SOONER", "SOOTHE", "SORBET", "SORDID", "SORELY", "SORROW", "SORTED", "SORTER", "SOUGHT", "SOUNDS", "SOURCE", "SOURED", "SOURLY", "SOVIET", "SOWING", "SPACER", "SPACES", "SPARED", "SPARSE", "SPEAKS", "SPEECH", "SPEEDO", "SPEEDS", "SPEEDY", "SPELLS", "SPENDS", "SPHERE", "SPICED", "SPIDER", "SPIGOT", "SPIKED", "SPINAL", "SPINES", "SPIRAL", "SPIRIT", "SPLASH", "SPLEEN", "SPLICE", "SPLINT", "SPOILS", "SPOKEN", "SPONGE", "SPONGY", "SPOOKY", "SPORTS", "SPORTY", "SPOTTY", "SPOUSE", "SPRAIN", "SPRANG", "SPRAWL", "SPREAD", "SPRING", "SPRINT", "SPRITE", "SPRITZ", "SPROUT", "SPRUCE", "SPUNKY", "SPYING", "SQUADS", "SQUALL", "SQUARE", "SQUASH", "SQUAWK", "SQUEAK", "SQUEAL", "SQUINT", "SQUIRE", "SQUIRM", "SQUIRT", "SQUISH", "STABLE", "STACKS", "STAGED", "STAGES", "STAIRS", "STAKES", "STALLS", "STAMEN", "STAMPS", "STANCE", "STANDS", "STANZA", "STAPLE", "STARCH", "STARED", "STARRY", "STARTS", "STARVE", "STASIS", "STATED", "STATES", "STATIC", "STATUE", "STATUS", "STAYED", "STEADY", "STEAMY", "STEELY", "STEERS", "STENCH", "STEREO", "STEWED", "STICKS", "STICKY", "STIFLE", "STIGMA", "STINGY", "STINKY", "STITCH", "STOCKS", "STOCKY", "STOLEN", "STOLID", "STONED", "STONES", "STOOGE", "STORED", "STORES", "STOREY", "STORMS", "STORMY", "STRAFE", "STRAIN", "STRAND", "STRAPS", "STRATA", "STREAK", "STREAM", "STREET", "STRESS", "STRICT", "STRIDE", "STRIFE", "STRIKE", "STRING", "STRIPE", "STRIPS", "STRIVE", "STROBE", "STRODE", "STROKE", "STROLL", "STRONG", "STRUCK", "STRUNG", "STUBBY", "STUCCO", "STUDIO", "STUFFY", "STUMPY", "STUPID", "STUPOR", "STURDY", "STYLES", "STYLUS", "STYMIE", "SUBDUE", "SUBMIT", "SUBSET", "SUBTLE", "SUBTLY", "SUBURB", "SUBWAY", "SUCCOR", "SUCKED", "SUCKER", "SUCKLE", "SUDDEN", "SUFFER", "SUFFIX", "SUGARY", "SUITED", "SUITOR", "SULFUR", "SULLEN", "SULTRY", "SUMMED", "SUMMER", "SUMMIT", "SUMMON", "SUNDAE", "SUNDAY", "SUNDER", "SUNDRY", "SUNKEN", "SUNLIT", "SUNSET", "SUNTAN", "SUPERB", "SUPINE", "SUPPER", "SUPPLE", "SUPPLY", "SURELY", "SURFER", "SURVEY", "SUTURE", "SWAMPY", "SWANKY", "SWATHE", "SWEATY", "SWEETS", "SWERVE", "SWITCH", "SWIVEL", "SWORDS", "SYMBOL", "SYNTAX", "SYRUPY", "SYSTEM",
                "TABLES", "TABLET", "TACKLE", "TACTIC", "TAGGED", "TAILOR", "TAKING", "TALBOT", "TALENT", "TALKED", "TALKER", "TALKIE", "TALLER", "TALLOW", "TAMALE", "TAMERS", "TAMING", "TAMPER", "TAMPON", "TANDEM", "TANGLE", "TANKER", "TANNED", "TAPING", "TAPPED", "TARGET", "TARIFF", "TARMAC", "TARRED", "TARTAN", "TARTAR", "TARTLY", "TASSEL", "TASTED", "TASTER", "TASTES", "TATTLE", "TATTOO", "TAUGHT", "TAVERN", "TAWDRY", "TAXING", "TEACUP", "TEAPOT", "TEASED", "TEASER", "TECHIE", "TECHNO", "TEDIUM", "TEENSY", "TEEPEE", "TEETER", "TELLER", "TEMPER", "TEMPLE", "TENANT", "TENDED", "TENDER", "TENDON", "TENNIS", "TENPIN", "TENSOR", "TENTHS", "TENURE", "TERMED", "TERROR", "TESTED", "TESTER", "TETHER", "TETRIS", "THANKS", "THATCH", "THAWED", "THEIRS", "THEISM", "THEMED", "THEMES", "THEORY", "THESES", "THESIS", "THIGHS", "THINGS", "THINGY", "THINKS", "THINLY", "THIRDS", "THIRST", "THIRTY", "THORAX", "THORNY", "THOUGH", "THRALL", "THRASH", "THREAD", "THREAT", "THRICE", "THRIFT", "THRILL", "THRIVE", "THROAT", "THROES", "THRONE", "THRONG", "THROWN", "THROWS", "THRUSH", "THRUST", "THUSLY", "THWACK", "THWART", "TICKER", "TICKET", "TICKLE", "TIDBIT", "TIDING", "TIERED", "TIGERS", "TIGHTS", "TILING", "TILTED", "TIMBER", "TIMBRE", "TIMELY", "TIMING", "TINDER", "TINGLE", "TINKER", "TINKLE", "TINNED", "TINSEL", "TINTED", "TIPPED", "TIPPET", "TIPTOE", "TIRADE", "TIRING", "TISSUE", "TITLED", "TITLES", "TITTER", "TOASTY", "TODDLE", "TOFFEE", "TOGGLE", "TOILET", "TOKENS", "TOMATO", "TOMBOY", "TOMCAT", "TONGUE", "TONNES", "TONSIL", "TOOLED", "TOOTHY", "TOPICS", "TOPPED", "TOPPER", "TOPPLE", "TORPID", "TORPOR", "TORQUE", "TORRID", "TOSSED", "TOUCAN", "TOUCHY", "TOUPEE", "TOUSLE", "TOWARD", "TOWELS", "TOWERS", "TOWING", "TOXICS", "TRACED", "TRACER", "TRACES", "TRACKS", "TRACTS", "TRADED", "TRADER", "TRADES", "TRAGIC", "TRAINS", "TRAITS", "TRANCE", "TRASHY", "TRAUMA", "TRAVEL", "TREATS", "TREATY", "TREBLE", "TREMOR", "TRENCH", "TRENDS", "TRENDY", "TRIAGE", "TRIALS", "TRIBAL", "TRIBES", "TRICKS", "TRICKY", "TRIFLE", "TRIPLE", "TRIPOD", "TRIPPY", "TRIVIA", "TROOPS", "TROPHY", "TROPIC", "TROUGH", "TROUPE", "TROWEL", "TRUANT", "TRUCKS", "TRUDGE", "TRUISM", "TRUSTS", "TRUSTY", "TRUTHS", "TRYING", "TRYOUT", "TUBING", "TUCKED", "TUCKER", "TUGGED", "TUMBLE", "TUMOUR", "TUMULT", "TUNDRA", "TUNING", "TUNNEL", "TURBAN", "TURBID", "TURGID", "TURKEY", "TURNED", "TURNIP", "TURRET", "TURTLE", "TUSSLE", "TUTORS", "TUXEDO", "TWELVE", "TWENTY", "TWINGE", "TWISTY", "TWITCH", "TYCOON", "TYPING", "TYPIST", "TYRANT",
                "ULCERS", "ULTIMA", "UMPIRE", "UNABLE", "UNBEND", "UNBIND", "UNBORN", "UNCLIP", "UNCLOG", "UNCOIL", "UNCORK", "UNCURL", "UNDEAD", "UNDONE", "UNEASE", "UNEASY", "UNEVEN", "UNFAIR", "UNFELT", "UNFOLD", "UNFURL", "UNHOLY", "UNHOOK", "UNHURT", "UNIONS", "UNIQUE", "UNISON", "UNITED", "UNJUST", "UNKIND", "UNLESS", "UNLIKE", "UNLOAD", "UNLOCK", "UNMASK", "UNPACK", "UNPAID", "UNPLUG", "UNREAD", "UNREAL", "UNREST", "UNRIPE", "UNROLL", "UNRULY", "UNSAFE", "UNSAID", "UNSEAL", "UNSEEN", "UNSOLD", "UNSUNG", "UNSURE", "UNTIDY", "UNTIED", "UNTOLD", "UNTRUE", "UNUSED", "UNVEIL", "UNWELL", "UNWIND", "UNWISE", "UNWORN", "UNWRAP", "UPBEAT", "UPDATE", "UPHELD", "UPHILL", "UPHOLD", "UPKEEP", "UPLIFT", "UPLINK", "UPLOAD", "UPROAR", "UPROOT", "UPSHOT", "UPSIDE", "UPTAKE", "UPTICK", "UPTIME", "UPTOWN", "UPWARD", "URCHIN", "URGENT", "URGING", "URINAL", "USABLE", "USEFUL", "UTERUS", "UTMOST", "UTOPIA",
                "VACANT", "VACATE", "VACUUM", "VAINLY", "VALLEY", "VALUED", "VALUES", "VALVES", "VANDAL", "VANISH", "VANITY", "VAPOUR", "VARIED", "VARIES", "VASTLY", "VAULTS", "VECTOR", "VEGGIE", "VEILED", "VEINED", "VELVET", "VENDOR", "VENTED", "VENUES", "VERBAL", "VERIFY", "VERMIN", "VERSED", "VERSES", "VERSUS", "VERTEX", "VESSEL", "VEXING", "VIABLE", "VICTIM", "VICTOR", "VIDEOS", "VIEWED", "VIEWER", "VIGOUR", "VIKING", "VILIFY", "VILLAS", "VIOLET", "VIOLIN", "VIRGIN", "VIRTUE", "VISAGE", "VISION", "VISITS", "VISUAL", "VOICED", "VOICES", "VOIDED", "VOLLEY", "VOLUME", "VOODOO", "VORTEX", "VOTERS", "VOTING", "VOWELS", "VOYAGE", "VOYEUR", "VULGAR",
                "WADDLE", "WADING", "WAFFLE", "WAGONS", "WAITED", "WAITER", "WAIVER", "WAKING", "WALKED", "WALKER", "WALLED", "WALLET", "WALNUT", "WALRUS", "WANDER", "WANING", "WANTED", "WANTON", "WARDEN", "WARDER", "WARILY", "WARMED", "WARMER", "WARMLY", "WARMTH", "WARNED", "WARPED", "WASABI", "WASHED", "WASHER", "WASTED", "WASTES", "WATERS", "WATERY", "WAVING", "WAXING", "WEAKEN", "WEAKER", "WEAKLY", "WEALTH", "WEANED", "WEAPON", "WEARER", "WEASEL", "WEBBED", "WEBCAM", "WEDDED", "WEEKLY", "WEENIE", "WEEVIL", "WEIGHT", "WEIRDO", "WELDED", "WELDER", "WETTER", "WHALES", "WHEELS", "WHEEZE", "WHEEZY", "WHILST", "WHIMSY", "WHINER", "WHINNY", "WHISKY", "WHITEN", "WHITES", "WHOLLY", "WICKED", "WIDELY", "WIDEST", "WIDGET", "WIDOWS", "WIENER", "WIGGLE", "WILDLY", "WILLOW", "WILTED", "WINDED", "WINDOW", "WINERY", "WINGED", "WINNER", "WINTER", "WINTRY", "WIPING", "WIRING", "WISDOM", "WISELY", "WISHED", "WISHES", "WITHER", "WITHIN", "WIZARD", "WOBBLE", "WOBBLY", "WOEFUL", "WOLVES", "WOMBAT", "WONDER", "WOODED", "WOODEN", "WOOING", "WOOLEN", "WOOLLY", "WORKED", "WORKER", "WORLDS", "WORSEN", "WORTHY", "WOUNDS", "WRAITH", "WREATH", "WRENCH", "WRETCH", "WRISTS", "WRITER", "WRITES", "WRITHE", "WYVERN",
                "XENONS", "XYLOSE",
                "YACHTS", "YEARLY", "YELLED", "YELLER", "YELLOW", "YIELDS", "YIPPEE", "YONDER", "YOUTHS", "YUPPIE",
                "ZAGGED", "ZAPPED", "ZAPPER", "ZEALOT", "ZEBRAS", "ZENITH", "ZEROES", "ZIGGED", "ZIGZAG", "ZINGER", "ZIPPED", "ZIPPER", "ZODIAC", "ZOMBIE", "ZONING", "ZOOMED", "ZYGOTE", };

    void Awake()
    {

    }

    void Start()
    {
        pageContents[0, 0] = "1TOP";
        pageContents[0, 1] = "1MID";
        pageContents[0, 2] = "1BOT";

        pageContents[1, 0] = "2TOP";
        pageContents[1, 1] = "2MID";
        pageContents[1, 2] = "2BOT";

        pageContents[2, 0] = "3TOP";
        pageContents[2, 1] = "3MID";
        pageContents[2, 2] = "3BOT";

        pageContents[3, 0] = "4TOP";
        pageContents[3, 1] = "4MID";
        pageContents[3, 2] = "4BOT";

        pageContents[4, 0] = "5TOP";
        pageContents[4, 1] = "5MID";
        pageContents[4, 2] = "5BOT";

        pageContents[5, 0] = "6TOP";
        pageContents[5, 1] = "6MID";
        pageContents[5, 2] = "6BOT";

        Wayfinding();

        string GoodHoodKeyWord = six_letter_words[UnityEngine.Random.Range(0, six_letter_words.Length)];
        encryptGoodHoodKeyword(GoodHoodKeyWord);
        GoodHoodCipher(GoodHoodKeyWord, "HIKURO");
        Debug.Log("KEYWORD: " + GoodHoodKeyWord);


        module.GetComponent<KMSelectable>().OnFocus += delegate { moduleSelected = true; };
        module.GetComponent<KMSelectable>().OnDefocus += delegate { moduleSelected = false; };
        ModuleId = ModuleIdCounter++;
        foreach (KMSelectable button in keyboard)
        {
            button.OnInteract += delegate () { keyboardPress(button); return false; };
        }
        right.OnInteract += delegate () { keyboardPress(right); return false; };

        left.OnInteract += delegate () { leftPress(); return false; };
        submit.OnInteract += delegate () { submitPress(); return false; };

    }

    void keyboardPress(KMSelectable button)
    {
        if (button == right && !pagesLocked)
        {
            rightPress();
            return;
        }
        if (!Submission)
        {
            Submission = true;
            for (int i = 0; i < ScreenTexts.Length; i++)
            {
                ScreenTexts[i].text = "";
            }
        }
        if (ScreenTexts[screenToWrite].text.Length >= 20) return;
        if (button == right)
        {
            ScreenTexts[screenToWrite].text += " ";
        }
        else
        {
            ScreenTexts[screenToWrite].text += button.name.ToUpper();
        }
        int length = ScreenTexts[screenToWrite].text.Length;
        ScreenTexts[screenToWrite].fontSize = length < 13 ? 317 : length == 13 ? 292 : length < 17 ? 237 : 185;



    }

    void submitPress()
        // Kuro has done things in the submitPress() function so please do not unKuro it :')
    {
        if (!Submission)
        {
            module.HandleStrike();
            return;
        }
        if (pagesLocked && routeStage == 1)
        {
            routeStage = 2;
            screenToWrite = 1;
        }
        else if (pagesLocked && routeStage == 2)
        {
            routeStage = 3;
            screenToWrite = 2;
        }
        else if (pagesLocked && routeStage == 3)
        {
            routeInputs[0] = ScreenTexts[0].text;
            routeInputs[1] = ScreenTexts[1].text;
            routeInputs[2] = ScreenTexts[2].text;

            if (CheckInterchanges(routeInputs))
            {
                angelUnicorn = false;
                ikeaUnicorn = false;
                SetDefaultKuroPages();
                HandleWayfindingSolve();
            }
            else if (CorrectUnicornInputs())
            {
                HandleWayfindingSolve();
            }
            else module.HandleStrike();

            Submission = false;
            pageUpdate(currentPage);

            routeStage = 1;
            screenToWrite = 0;
        }
    }

    void leftPress()
    {
        screenToWrite = 0;
        routeStage = 1;
        if (Submission && pagesLocked)
        {
            currentPage = 1;
            Submission = false;
        }
        else if (pagesLocked)
        {
            return;
        }
        else if (Submission)
        {
            Submission = false;
        }
        Audio.PlaySoundAtTransform("ArrowPress", transform);
        currentPage = (currentPage - 1);
        if (currentPage == -1) currentPage = pages - 1;

        pageUpdate(currentPage);
    }

    void rightPress()
    {
        if (Submission)
        {
            Submission = false;
        }
        Audio.PlaySoundAtTransform("ArrowPress", transform);
        currentPage = (currentPage + 1) % pages;
        pageUpdate(currentPage);


    }

    void ChangeBGImage()
    {
        if (currentPage <= 3)
        {
            BGMat.mainTexture = BackgroundImages[tubecipherBackgroundNumber];
        }
        else BGMat.mainTexture = BackgroundImages[4];
    }

    // Sets each screen to the correct colour depending on the page being displayed.
    void SetScreenColours()
    {
        if (angelUnicorn || ikeaUnicorn) return;

        if (currentPage == 2)
        {
            ScreenTexts[0].color = Color.white;
            ScreenTexts[1].color = new Color(linesTakenPathOne[0].Line.RGBValues[0], linesTakenPathOne[0].Line.RGBValues[1], linesTakenPathOne[0].Line.RGBValues[2]);
            ScreenTexts[2].color = new Color(linesTakenPathOne[1].Line.RGBValues[0], linesTakenPathOne[1].Line.RGBValues[1], linesTakenPathOne[1].Line.RGBValues[2]);
        }
        else if (currentPage == 3)
        {
            ScreenTexts[0].color = new Color(linesTakenPathTwo[0].Line.RGBValues[0], linesTakenPathTwo[0].Line.RGBValues[1], linesTakenPathTwo[0].Line.RGBValues[2]);
            ScreenTexts[1].color = new Color(linesTakenPathTwo[1].Line.RGBValues[0], linesTakenPathTwo[1].Line.RGBValues[1], linesTakenPathTwo[1].Line.RGBValues[2]);
            ScreenTexts[2].color = new Color(linesTakenPathTwo[2].Line.RGBValues[0], linesTakenPathTwo[2].Line.RGBValues[1], linesTakenPathTwo[2].Line.RGBValues[2]);
        }
        else
        {
            ScreenTexts[0].color = Color.white;
            ScreenTexts[1].color = Color.white;
            ScreenTexts[2].color = Color.white;
        }
    }

    void pageUpdate(int page)
    {
        SetScreenColours();
        ChangeBGImage();

        if (currentPage == 0)
        {
            TrainsImage.SetActive(true);
            subText.SetActive(false);
        }
        else
        {
            TrainsImage.SetActive(false);
            subText.SetActive(true);
        }
        for (int i = 0; i < 3; i++)
        {
            ScreenTexts[i].text = pageContents[page, i];
            int length = pageContents[page, i].Length;
            ScreenTexts[i].fontSize = length < 13 ? 317 : length == 13 ? 292 : length < 17 ? 237 : 185;
        }
    }

    private int getPositionFromChar(char c) // More Keyboard Support
    {
        return "QWERTYUIOPASDFGHJKLZXCVBNM".IndexOf(c);
    }

    void Update()
    {
        //CHANGE THIS TO IF MODULE SELECTED AFTER DONE
        if (!moduleSelected)
        {
            for (var ltr = 0; ltr < 26; ltr++) //Keyboard Support
            {
                if (Input.GetKeyDown(((char)('a' + ltr)).ToString()))
                {

                    keyboard[getPositionFromChar((char)('A' + ltr))].OnInteract();
                }
            }
            if (Input.GetKeyDown(KeyCode.Return))
                submit.OnInteract();
            if (Input.GetKeyDown(KeyCode.Space) && pagesLocked)
                keyboardPress(right);
        }
    }


    #region GoodHoodStuff

    string encryptGoodHoodKeyword(string word)
    {
        string alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        int posOfFirstLetter = Bomb.GetPortCount() % 8;
        for (int i = 0; i < posOfFirstLetter - 1; i++)
        {
            char randomChar = alpha[UnityEngine.Random.Range(0, alpha.Length)];
            word = word.Insert(0, randomChar.ToString());
        }
        while (word.Length < 12)
        {
            char randomChar = alpha[UnityEngine.Random.Range(0, alpha.Length)];
            word += randomChar.ToString();
        }
        string newWord = "";
        for (int letter = 0; letter < word.Length; letter++)
        {
            int indexOfLetter = alpha.IndexOf(word[letter]);
            indexOfLetter -= Bomb.GetBatteryCount();
            if (indexOfLetter < 0) indexOfLetter += 26;
            newWord += alpha[indexOfLetter];
        }
        word = newWord;
        //pageContents[0, 0] = word;
        //pageUpdate(0);
        string ayoString = "AOYYOAAOAYOY";
        int ayoShift = Bomb.GetSerialNumberNumbers().Last() + 1;
        string[] ayoStringShifted = new string[12];
        for (int i = 0; i < ayoString.Length; i++)
        {
            ayoStringShifted[i] = ayoString[(i + ayoShift) % 12].ToString();
        }
        List<int> APositions = new List<int>();
        List<int> YPositions = new List<int>();
        List<int> OPositions = new List<int>();

        for (int i = 0; i < ayoStringShifted.Length; i++)
        {
            switch (ayoStringShifted[i])
            {
                case "A":
                    APositions.Add(i);
                    break;
                case "Y":
                    YPositions.Add(i);
                    break;
                case "O":
                    OPositions.Add(i);
                    break;

            }

        }
        string[] encryptedKeyWordArr = new string[12];
        for (int i = 0; i < word.Length; i++)
        {
            if (i >= 0 && i <= 3)
            {
                encryptedKeyWordArr[APositions[i]] = word[i].ToString();
            }
            else if (i >= 4 && i <= 7)
            {
                encryptedKeyWordArr[YPositions[i % 4]] = word[i].ToString();
            }
            else
            {
                encryptedKeyWordArr[OPositions[i % 4]] = word[i].ToString();
            }
        }
        string encryptedKeyWord = "";
        foreach (string letter in encryptedKeyWordArr)
        {
            encryptedKeyWord += letter;
        }

        Debug.Log("Final " + encryptedKeyWord);



        return "bla";
    }

    void GoodHoodCipher(string keyword, string word)
    {
        string key2Initial = "LLLLLL";
        string key2 = "";
        for (int i = 0; i < key2Initial.Length; i++)
        {
            char serialChar = Bomb.GetSerialNumber()[i];
            int serialCharNum;
            if (Char.IsLetter(serialChar))
            {
                serialCharNum = alphaNum(serialChar.ToString());
            }
            else
            {
                serialCharNum = Int32.Parse(serialChar.ToString());
            }

            int liemuhIndex = 12;
            if (serialCharNum % 2 == 0)
            {
                int newIndex = (serialCharNum + liemuhIndex) % 26;
                if (newIndex == 0) newIndex = 26;
                key2 += toAlpha(newIndex);
            }
            else
            {
                int newIndex = (liemuhIndex - serialCharNum);
                if (newIndex < 1)
                {
                    newIndex += 26;
                }
                key2 += toAlpha(newIndex);
            }
        }
        string finalKey = keyword + key2;
        Debug.Log("FINALKEY " + finalKey);
        string[] finalKeyArray = new string[12];

        for (int i = 0; i < finalKey.Length; i++)
        {
            finalKeyArray[i] = finalKey[i].ToString();
        }

        string[] finalShifted = new string[12];
        for (int i = 0; i < finalKey.Length; i++)
        {
            finalShifted[(i + (Bomb.GetIndicators().Count() + 2)) % 12] = finalKeyArray[i].ToString();
        }
        finalKey = String.Join("", finalShifted);

        finalKey = finalKey.Substring(0, word.Length);

        string[] answer = new string[word.Length];

        for (int i = 0; i < finalKey.Length; i++)
        {
            int newChar = (alphaNum(finalKey[i].ToString()) - alphaNum(word[i].ToString())) % 26;
            if (newChar < 1)
            {
                newChar += 26;
            }
            answer[word.Length - 1 - i] = toAlpha(newChar);
        }

        string answerString = String.Join("", answer);
        // pageContents[0, 0] = answerString;
        pageUpdate(0);

    }

    int alphaNum(string letter)
    {
        string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        int letIndex = alphabet.IndexOf(letter) + 1;
        return letIndex;
    }

    string toAlpha(int index)
    {
        string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        return (alphabet[index - 1]).ToString();
    }

    #endregion

    // Kuro formally apologises to all individuals (including Kuro himself) who find themselves needing to read the code located in the Wayfinding region.
    // This is Kuro's first "major" project, and so Kuro has learnt a lot during it, but this is too much for Kuro to be bothered to fix.
    // If you MUST continue, avoid at all costs all 200+ lines of the CheckInterchanges() method.
    #region Wayfinding
    void Wayfinding()
    {
        lines = GenerateMap();
        PickStations();

        pageContents[0, 0] = origin;
        pageContents[0, 1] = "TO";
        pageContents[0, 2] = destination;

        if (origin == "HAMMERSMITH" || destination == "HAMMERSMITH") tubecipherBackgroundNumber = 1;
        ChangeBGImage();

        CheckImpossibilities();
        CheckUnicorns();
    }

    void PickStations()
    {

        int i = Rnd.Range(0, 11);
        int j = Rnd.Range(0, lines[i].Stations.Count());
        string linesWithOrigin = "";
        char nextLineLetter;
        const string Alphabet = "ABCDEFGHIJK";
            
        origin = lines[i].Stations[j];

        foreach (char letter in Alphabet)
        {
            if (lines[alphaNum(letter.ToString()) - 1].Stations.Contains(origin)) linesWithOrigin += letter;
        }

        do
        {
            nextLineLetter = Alphabet[Rnd.Range(0, 11)];
        }
        while (linesWithOrigin.Contains(nextLineLetter));

        i = alphaNum(nextLineLetter.ToString()) - 1;

        do
        {
            j = Rnd.Range(0, lines[i].Stations.Count());
            destination = lines[i].Stations[j];
        }
        while (OnIllegalLine(destination, linesWithOrigin) && CheckForBankMonumentLiverpoolStreetMoorgate());
    }

    bool CheckForBankMonumentLiverpoolStreetMoorgate()
    {
        string[] bankMonument = { "BANK", "MONUMENT" };
        string[] LiverpoolStreetMoorgate = { "LIVERPOOL STREET", "MOORGATE" };

        if (bankMonument.Contains(origin) && bankMonument.Contains(destination)) return false;
        if (LiverpoolStreetMoorgate.Contains(origin) && LiverpoolStreetMoorgate.Contains(destination)) return false;

        return true;
    }

    bool OnIllegalLine(string station, string IllegalLines)
    {
        foreach (char letter in IllegalLines)
        {
            if (lines[alphaNum(letter.ToString()) - 1].Stations.Contains(station)) return true;
        }

        return false;
    }

    void CheckImpossibilities()
    {
        string[] endpoints = { origin, destination };
        string[] metropolitanLineExclusives = { "CHESHAM", "CHALFONT N LATIMER", "AMERSHAM", "CHORLEYWOOD", "RICKMANSWORTH", "MOOR PARK", "WATFORD", "CROXLEY", "NORTHWOOD", "NORTHWOOD HILLS", "PINNER", "NORTH HARROW", "HARROW ON THE HILL", "WEST HARROW", "NORTHWICK PARK", "PRESTON ROAD" };
        string[] districtLineExclusives = { "UPNEY", "BECONTREE", "DAGENHAM HEATHWAY", "DAGENHAM EAST", "ELM PARK", "HORNCHURCH", "UPMINSTER BRIDGE", "UPMINSTER", "WIMBLEDON", "WIMBLEDON PARK", "SOUTHFIELDS", "EAST PUTNEY", "PUTNEY BRIDGE", "PARSONS GREEN", "FULHAM BROADWAY", "WEST BROMPTON", "WEST KENSINGTON", "RAVENSCOURT PARK", "STAMFORD BROOK", "GUNNERSBURY", "KEW GARDENS", "RICHMOND", "CHISWICK PARK" };

        if ((endpoints.Contains("MORNINGTON CRESCENT") || endpoints.Contains("GOODGE STREET") || endpoints.Contains("BATTERSEA POWER ST") || endpoints.Contains("NINE ELMS")) && (metropolitanLineExclusives.Contains(endpoints[0]) || metropolitanLineExclusives.Contains(endpoints[1])))
        {
            origin = "HAINAULT";
            destination = "COCKFOSTERS";
        }

        if ((metropolitanLineExclusives.Contains(endpoints[0]) || metropolitanLineExclusives.Contains(endpoints[1])) && (districtLineExclusives.Contains(endpoints[0]) || districtLineExclusives.Contains(endpoints[1])))
        {
            origin = "HAINAULT";
            destination = "COCKFOSTERS";
        }
    }

    // Big scary function :(((( Kuro apologises again.
    bool CheckInterchanges(string[] interchanges)
        // Check validity of paths between the two given stations on the module.
    {
        TubeLine.PathFinder p;
        List<TubeLine.Path>[] pathOneSections = new List<TubeLine.Path>[2];
        List<TubeLine.Path>[] pathTwoSections = new List<TubeLine.Path>[3];
        List<string> pathTwoIds = new List<string>();
        string[] funnyLines = { "CIRCLE", "METROPOLITAN", "HAMMERSMITH N CITY" };
        List<TubeLine.Path> section;
        var onePaths = new List<string>();
        var twoPathNumbers = new List<int>();
        int i;

        for (int j = 0; j < interchanges.Length; j++)
        {
            if (interchanges[j] == "ST JAMESS PARK") interchanges[j] = "ST JAMES PARK";
        }

        for (int j = 0; j < linesTakenPathOne.Length; j++)
        {
            linesTakenPathOne[j] = null;
        }

        for (int j = 0; j < linesTakenPathTwo.Length; j++)
        {
            linesTakenPathTwo[j] = null;
        }

        if (interchanges.Length != interchanges.Distinct().Count()) return false;

        // Checking path 1:
        pathOneSections[0] = new List<TubeLine.Path>();
        foreach (TubeLine line in lines)
        {
            p = new TubeLine.PathFinder(line, origin, interchanges[0]);
            if (p.HasPath()) pathOneSections[0].Add(p.ProducePath());
        }

        pathOneSections[1] = new List<TubeLine.Path>();
        foreach (TubeLine line in lines)
        {
            if ((interchanges[0] == "MOORGATE" || interchanges[0] == "LIVERPOOL STREET") && !funnyLines.Contains(line.Name) && destination != "MOORGATE" && destination != "LIVERPOOL STREET")
            {
                p = new TubeLine.PathFinder(line, "LIVERPOOL STREET", destination);
                if (p.HasPath()) pathOneSections[1].Add(p.ProducePath());
                p = new TubeLine.PathFinder(line, "MOORGATE", destination);
                if (p.HasPath()) pathOneSections[1].Add(p.ProducePath());
            }
            else if ((interchanges[0] == "BANK" || interchanges[0] == "MONUMENT") && destination != "BANK" && destination != "MONUMENT")
            {
                p = new TubeLine.PathFinder(line, "MONUMENT", destination);
                if (p.HasPath()) pathOneSections[1].Add(p.ProducePath());
                p = new TubeLine.PathFinder(line, "BANK", destination);
                if (p.HasPath()) pathOneSections[1].Add(p.ProducePath());
            }
            else
            {
                p = new TubeLine.PathFinder(line, interchanges[0], destination);
                if (p.HasPath()) pathOneSections[1].Add(p.ProducePath());
            }
        }

        // Checking validity here.
        if (pathOneSections[0].Count() == 0 || pathOneSections[1].Count() == 0) { Debug.Log("No path on path 1"); return false; }
        if ((pathOneSections[0].Count == 1 && pathOneSections[1].Count == 1) && pathOneSections[0][0].id == pathOneSections[1][0].id) { Debug.Log("Path requires same line path 1"); return false; }

        if (pathOneSections[1].Count == 1)
        {
            linesTakenPathOne[1] = pathOneSections[1][0];
            i = Rnd.Range(0, pathOneSections[0].Count);

            if (pathOneSections[0][i].id != linesTakenPathOne[1].id) linesTakenPathOne[0] = pathOneSections[0][i];
            else
            {
                i = 0;
                do
                {
                    linesTakenPathOne[0] = pathOneSections[0][i];
                    i++;
                } while (linesTakenPathOne[0].id == linesTakenPathOne[1].id);
            }
        }
        else
        {
            i = Rnd.Range(0, pathOneSections[0].Count);
            linesTakenPathOne[0] = pathOneSections[0][i];

            i = Rnd.Range(0, pathOneSections[1].Count);

            if (pathOneSections[1][i].id != linesTakenPathOne[0].id) linesTakenPathOne[1] = pathOneSections[1][i];
            else
            {
                i = 0;
                do
                {
                    linesTakenPathOne[1] = pathOneSections[1][i];
                    i++;
                } while (linesTakenPathOne[1].id == linesTakenPathOne[0].id);
            }
        }

        // Checking path 2:
        pathTwoSections[0] = new List<TubeLine.Path>();
        foreach (TubeLine line in lines)
        {
            p = new TubeLine.PathFinder(line, origin, interchanges[1]);
            if (p.HasPath()) pathTwoSections[0].Add(p.ProducePath());
        }

            pathTwoSections[1] = new List<TubeLine.Path>();
        foreach (TubeLine line in lines)
        {
            if ((interchanges[1] == "MOORGATE" || interchanges[1] == "LIVERPOOL STREET") && !funnyLines.Contains(line.Name) && interchanges[2] != "MOORGATE" && interchanges[2] != "LIVERPOOL STREET")
            {
                p = new TubeLine.PathFinder(line, "LIVERPOOL STREET", interchanges[2]);
                if (p.HasPath()) pathTwoSections[1].Add(p.ProducePath());
                p = new TubeLine.PathFinder(line, "MOORGATE", interchanges[2]);
                if (p.HasPath()) pathTwoSections[1].Add(p.ProducePath());
            }
            else if ((interchanges[1] == "BANK" || interchanges[1] == "MONUMENT") && interchanges[2] != "BANK" && interchanges[2] != "MONUMENT")
            {
                p = new TubeLine.PathFinder(line, "MONUMENT", interchanges[2]);
                if (p.HasPath()) pathTwoSections[1].Add(p.ProducePath());
                p = new TubeLine.PathFinder(line, "BANK", interchanges[2]);
                if (p.HasPath()) pathTwoSections[1].Add(p.ProducePath());
            }
            else
            {
                p = new TubeLine.PathFinder(line, interchanges[1], interchanges[2]);
                if (p.HasPath()) pathTwoSections[1].Add(p.ProducePath());
            }
        }

        pathTwoSections[2] = new List<TubeLine.Path>();
        foreach (TubeLine line in lines)
        {
            if ((interchanges[2] == "MOORGATE" || interchanges[2] == "LIVERPOOL STREET") && !funnyLines.Contains(line.Name) && destination != "MOORGATE" && destination != "LIVERPOOL STREET")
            {
                p = new TubeLine.PathFinder(line, "LIVERPOOL STREET", destination);
                if (p.HasPath()) pathTwoSections[2].Add(p.ProducePath());
                p = new TubeLine.PathFinder(line, "MOORGATE", destination);
                if (p.HasPath()) pathTwoSections[2].Add(p.ProducePath());
            }
            else if ((interchanges[2] == "BANK" || interchanges[2] == "MONUMENT") && destination != "BANK" && destination != "MONUMENT")
            {
                p = new TubeLine.PathFinder(line, "MONUMENT", destination);
                if (p.HasPath()) pathTwoSections[2].Add(p.ProducePath());
                p = new TubeLine.PathFinder(line, "BANK", destination);
                if (p.HasPath()) pathTwoSections[2].Add(p.ProducePath());
            }
            else
            {
                p = new TubeLine.PathFinder(line, interchanges[2], destination);
                if (p.HasPath()) pathTwoSections[2].Add(p.ProducePath());
            }
        }

        // Checking validity here.
        for (int j = 0; j < 3; j++)
        {
            section = pathTwoSections[j];

            switch (section.Count())
            {
                case 0:
                    Debug.Log("No path on path 2 section " + j.ToString());
                    return false;
                case 1:
                    if (onePaths.Contains(section[0].id)) { Debug.Log("No path on path 2");  return false; }
                    else onePaths.Add(section[0].id);
                    linesTakenPathTwo[j] = section[0];
                    break;
                case 2:
                    twoPathNumbers.Add(j);
                    break;
            }
        }

        foreach (TubeLine.Path path in linesTakenPathTwo)
        {
            if (path != null) pathTwoIds.Add(path.id);
        }

        foreach (int j in twoPathNumbers)
        {
            i = Rnd.Range(0, 2);
            if (!pathTwoIds.Contains(pathTwoSections[j][i].id))
            {
                linesTakenPathTwo[j] = pathTwoSections[j][i];
                pathTwoIds.Add(pathTwoSections[j][i].id);
            }
            else
            {
                foreach (TubeLine.Path path in pathTwoSections[j])
                {
                    if (!linesTakenPathTwo.Contains(path)) linesTakenPathTwo[j] = path;
                }

                if (linesTakenPathTwo[j] == null)
                {
                    Debug.Log("Can't assign path on path 2 (twopaths)");
                    return false;
                }
            }
        }

        for (int j = 0; j < 3; j++)
        {
            if (linesTakenPathTwo[j] == null)
            {
                foreach (TubeLine.Path path in pathTwoSections[j])
                {
                    if (!linesTakenPathTwo.Contains(path)) linesTakenPathTwo[j] = path;
                }

                if (linesTakenPathTwo[j] == null)
                {
                    Debug.Log("Can't assign path on path 2 (end)");
                    return false;
                }
            }
        }

        return true;
    }

    TubeLine[] GenerateMap()
    // Generates all 11 Tube lines and their branches.
    {

        TubeLine[] lines = new TubeLine[11];

        lines[0] = new TubeLine("BAKERLOO", "B36305", 0);
        string[] bakerlooPath = { "HARROW N WEALDSTONE", "KENTON", "SOUTH KENTON", "NORTH WEMBLEY", "WEMBLEY CENTRAL", "STONEBRIDGE PARK", "HARLSEDEN", "WILLESDEN JUNCTION", "KENSAL GREEN", "QUEENS PARK", "KILBURN PARK", "MAIDA VALE", "WARWICK AVENUE", "PADDINGTON", "EDGWARE ROAD", "MARYLEBONE", "BAKER STREET", "REGENTS PARK", "OXFORD CIRCUS", "PICCADILLY CIRCUS", "CHARING CROSS", "EMBANKMENT", "WATERLOO", "LAMBETH NORTH", "ELEPHANT N CASTLE" };
        lines[0].AddBranch(bakerlooPath);

        lines[1] = new TubeLine("CENTRAL", "E32017", 1);
        string[] centralPath1 = { "WEST RUISLIP", "RUISLIP GARDENS", "SOUTH RUISLIP", "NORTHOLT", "GREENFORD", "PERIVALE", "HANGER LANE", "NORTH ACTON" };
        string[] centralPath2 = { "EALING BROADWAY", "WEST ACTON", "NORTH ACTON" };
        string[] centralPath3 = { "NORTH ACTON", "EAST ACTON", "WHITE CITY", "SHEPHERDS BUSH", "HOLLAND PARK", "NOTTING HILL GATE", "QUEENSWAY", "LANCASTER GATE", "MARBLE ARCH", "BOND STREET", "OXFORD CIRCUS", "TOTTENHAM COURT ROAD", "HOLBORN", "CHANCERY LANE", "ST PAULS", "BANK", "LIVERPOOL STREET", "BETHNAL GREEN", "MILE END", "STRATFORD", "LEYTON", "LEYTONSTONE" };
        string[] centralPath4 = { "LEYTONSTONE", "WANSTEAD", "REDBRIDGE", "GANTS HILL", "NEWBURY PARK", "BARKINGSIDE", "FAIRLOP", "HAINAULT" };
        string[] centralPath5 = { "LEYTONSTONE", "SNARESBROOK", "SOUTH WOODFORD", "WOODFORD", "BUCKHURST HILL", "LOUGHTON", "DEBDEN", "THEYDON BOIS", "EPPING" };
        lines[1].AddBranch(centralPath1);
        lines[1].AddBranch(centralPath2);
        lines[1].AddBranch(centralPath3);
        lines[1].AddBranch(centralPath4);
        lines[1].AddBranch(centralPath5);

        lines[2] = new TubeLine("CIRCLE", "FFD300", 2);
        string[] circlePath = { "HAMMERSMITH", "GOLDHAWK ROAD", "SHEPHERDS BUSH MKT", "WOOD LANE", "LATIMER ROAD", "LADBROKE GROVE", "WESTBOURNE PARK", "ROYAL OAK", "PADDINGTON", "EDGWARE ROAD", "BAKER STREET", "GREAT PORTLAND ST", "EUSTON SQUARE", "KINGS CROSS", "FARRINGDON", "BARBICAN", "MOORGATE", "LIVERPOOL STREET", "ALDGATE", "TOWER HILL", "MONUMENT", "CANNON STREET", "MANSION HOUSE", "BLACKFRIARS", "TEMPLE", "EMBANKMENT", "WESTMINSTER", "ST JAMES PARK", "VICTORIA", "SLOANE SQUARE", "SOUTH KENSINGTON", "GLOUCESTER ROAD", "HIGH STREET KEN", "NOTTING HILL GATE", "BAYSWATER", "PADDINGTON", "EDGWARE ROAD" };
        lines[2].AddBranch(circlePath);

        lines[3] = new TubeLine("DISTRICT", "00782A", 3);
        string[] districtPath1 = { "EALING BROADWAY", "EALING COMMON", "ACTON TOWN", "CHISWICK PARK", "TURNHAM GREEN" };
        string[] districtPath2 = { "RICHMOND", "KEW GARDENS", "GUNNERSBURY", "TURNHAM GREEN" };
        string[] districtPath3 = { "TURNHAM GREEN", "STAMFORD BROOK", "RAVENSCOURT PARK", "HAMMERSMITH", "BARONS COURT", "WEST KENSINGTON", "EARLS COURT" };
        string[] districtPath4 = { "WIMBLEDON", "WIMBLEDON PARK", "SOUTHFIELDS", "EAST PUTNEY", "PUTNEY BRIDGE", "PARSONS GREEN", "FULHAM BROADWAY", "WEST BROMPTON", "EARLS COURT" };
        string[] districtPath5 = { "EARLS COURT", "HIGH STREET KEN", "NOTTING HILL GATE", "BAYSWATER", "PADDINGTON", "EDGWARE ROAD" };
        string[] districtPath6 = { "EARLS COURT", "GLOUCESTER ROAD", "SOUTH KENSINGTON", "SLOANE SQUARE", "VICTORIA", "ST JAMES PARK", "WESTMINSTER", "EMBANKMENT", "TEMPLE", "BLACKFRIARS", "MANSION HOUSE", "CANNON STREET", "MONUMENT", "TOWER HILL", "ALDGATE EAST", "WHITECHAPEL", "STEPNEY GREEN", "MILE END", "BOW ROAD", "BROMLEY BY BOW", "WEST HAM", "PLAISTOW", "UPTON PARK", "EAST HAM", "BARKING", "UPNEY", "BECONTREE", "DAGENHAM HEATHWAY", "DAGENHAM EAST", "ELM PARK", "HORNCHURCH", "UPMINSTER BRIDGE", "UPMINSTER" };
        lines[3].AddBranch(districtPath1);
        lines[3].AddBranch(districtPath2);
        lines[3].AddBranch(districtPath3);
        lines[3].AddBranch(districtPath4);
        lines[3].AddBranch(districtPath5);
        lines[3].AddBranch(districtPath6);

        lines[4] = new TubeLine("HAMMERSMITH N CITY", "F3A9BB", 4);
        string[] hamNcheesePath = { "HAMMERSMITH", "GOLDHAWK ROAD", "SHEPHERDS BUSH MKT", "WOOD LANE", "LATIMER ROAD", "LADBROKE GROVE", "WESTBOURNE PARK", "ROYAL OAK", "PADDINGTON", "EDGWARE ROAD", "BAKER STREET", "GREAT PORTLAND ST", "EUSTON SQUARE", "KINGS CROSS", "FARRINGDON", "BARBICAN", "MOORGATE", "LIVERPOOL STREET", "ALDGATE EAST", "WHITECHAPEL", "STEPNEY GREEN", "MILE END", "BOW ROAD", "BROMLEY BY BOW", "WEST HAM", "PLAISTOW", "UPTON PARK", "EAST HAM", "BARKING" };
        lines[4].AddBranch(hamNcheesePath);

        lines[5] = new TubeLine("JUBILEE", "A0A5A9", 5);
        string[] jubileePath = { "STANMORE", "CANONS PARK", "QUEENSBURY", "KINGSBURY", "WEMBLEY PARK", "NEASDEN", "DOLLIS HILL", "WILLESDEN GREEN", "KILBURN", "WEST HAMPSTEAD", "FINCHLEY ROAD", "SWISS COTTAGE", "ST JOHNS WOOD", "BAKER STREET", "BOND STREET", "GREEN PARK", "WESTMINSTER", "WATERLOO", "SOUTHWARK", "LONDON BRIDGE", "BERMONDSEY", "CANADA WATER", "CANARY WHARF", "NORTH GREENWICH", "CANNING TOWN", "WEST HAM", "STRATFORD" };
        lines[5].AddBranch(jubileePath);

        lines[6] = new TubeLine("METROPOLITAN", "9B0056", 6);
        string[] metropolitanPath1 = { "CHESHAM", "CHALFONT N LATIMER" };
        string[] metropolitanPath2 = { "AMERSHAM", "CHALFONT N LATIMER" };
        string[] metropolitanPath3 = { "CHALFONT N LATIMER", "CHORLEYWOOD", "RICKMANSWORTH", "MOOR PARK" };
        string[] metropolitanPath4 = { "WATFORD", "CROXLEY", "MOOR PARK" };
        string[] metropolitanPath5 = { "MOOR PARK", "NORTHWOOD", "NORTHWOOD HILLS", "PINNER", "NORTH HARROW", "HARROW ON THE HILL" };
        string[] metropolitanPath6 = { "UXBRIDGE", "HILLINGDON", "ICKENHAM", "RUISLIP", "RUISLIP MANOR", "EASTCOTE", "RAYNERS LANE", "WEST HARROW", "HARROW ON THE HILL" };
        string[] metropolitanPath7 = { "HARROW ON THE HILL", "NORTHWICK PARK", "PRESTON ROAD", "WEMBLEY PARK", "FINCHLEY ROAD", "BAKER STREET", "GREAT PORTLAND ST", "EUSTON SQUARE", "KINGS CROSS", "FARRINGDON", "BARBICAN", "MOORGATE", "LIVERPOOL STREET", "ALDGATE" };
        lines[6].AddBranch(metropolitanPath1);
        lines[6].AddBranch(metropolitanPath2);
        lines[6].AddBranch(metropolitanPath3);
        lines[6].AddBranch(metropolitanPath4);
        lines[6].AddBranch(metropolitanPath5);
        lines[6].AddBranch(metropolitanPath6);
        lines[6].AddBranch(metropolitanPath7);

        lines[7] = new TubeLine("NORTHERN", "000000", 7);
        string[] northernPath1 = { "EDGWARE", "BURNT OAK", "COLINDALE", "HENDON CENTRAL", "BRENT CROSS", "GOLDERS GREEN", "HAMPSTEAD", "BELSIZE PARK", "CHALK FARM", "CAMDEN TOWN" };
        string[] northernPath2 = { "HIGH BARNET", "TOTT N WHETSTONE", "WOODSIDE PARK", "WEST FINCHLEY", "FINCHLEY CENTRAL" };
        string[] bitchPath1 = { "MILL HILL EAST", "FINCHLEY CENTRAL" };
        string[] northernPath3 = { "FINCHLEY CENTRAL", "EAST FINCHLEY", "HIGHGATE", "ARCHWAY", "TUFNELL PARK", "KENTISH TOWN", "CAMDEN TOWN" };
        string[] northernPath4 = { "CAMDEN TOWN", "MORNINGTON CRESCENT", "EUSTON", "WARREN STREET", "GOODGE STREET", "TOTTENHAM COURT ROAD", "LEICESTER SQUARE", "CHARING CROSS", "EMBANKMENT", "WATERLOO", "KENNINGTON", "OVAL" };
        string[] northernPath5 = { "CAMDEN TOWN", "EUSTON", "KINGS CROSS", "ANGEL", "OLD STREET", "MOORGATE", "BANK", "LONDON BRIDGE", "BOROUGH", "ELEPHANT N CASTLE", "KENNINGTON", "OVAL" };
        string[] bitchPath2 = { "CAMDEN TOWN", "MORNINGTON CRESCENT", "EUSTON", "WARREN STREET", "GOODGE STREET", "TOTTENHAM COURT ROAD", "LEICESTER SQUARE", "CHARING CROSS", "EMBANKMENT", "WATERLOO", "KENNINGTON", "NINE ELMS", "BATTERSEA PWR STN" };
        string[] northernPath6 = { "OVAL", "STOCKWELL", "CLAPHAM NORTH", "CLAPHAM COMMON", "CLAPHAM SOUTH", "BALHAM", "TOOTING BEC", "TOOTING BROADWAY", "COLLIERS WOOD", "SOUTH WIMBLEDON", "MORDEN" };
        lines[7].AddBranch(northernPath1);
        lines[7].AddBranch(northernPath2);
        lines[7].AddBranch(bitchPath1);
        lines[7].AddBranch(northernPath3);
        lines[7].AddBranch(northernPath4);
        lines[7].AddBranch(northernPath5);
        lines[7].AddBranch(northernPath6);
        lines[7].AddBranch(bitchPath2);

        lines[8] = new TubeLine("PICCADILLY", "003688", 8);
        string[] piccadillyPath1 = { "HEATHROW T5", "HEATHROW T2 N 3", "HATTON CROSS", "HOUNSLOW WEST", "HOUNSLOW CENTRAL", "HOUNSLOW EAST", "OSTERLEY", "BOSTON MANOR", "NORTHFIELDS", "SOUTH EALING", "ACTON TOWN" };
        string[] piccadillyPath2 = { "UXBRIDGE", "HILLINGDON", "ICKENHAM", "RUISLIP", "RUISLIP MANOR", "EASTCOTE", "RAYNERS LANE", "SOUTH HARROW", "SUDBURY HILL", "SUDBURY TOWN", "ALPERTON", "PARK ROYAL", "NORTH EALING", "EALING COMMON", "ACTON TOWN" };
        //                                                                                                                       :O
        string[] piccadillyPath3 = { "ACTON TOWN", "TURNHAM GREEN", "HAMMERSMITH", "BARONS COURT", "EARLS COURT", /* :O */"GLOUCESTER ROAD"/* :O */, "SOUTH KENSINGTON", "KNIGHTSBRIDGE", "HYDE PARK CORNER", "GREEN PARK", "PICCADILLY CIRCUS", "LEICESTER SQUARE", "COVENT GARDEN", "HOLBORN", "RUSSELL SQUARE", "KINGS CROSS", "CALEDONIAN ROAD", "HOLLOWAY ROAD", "ARSENAL", "FINSBURY PARK", "MANOR HOUSE", "TURNPIKE LANE", "WOOD GREEN", "BOUNDS GREEN", "ARNOS GROVE", "SOUTHGATE", "OAKWOOD", "COCKFOSTERS" };
        //                                                                                                                       :O
        lines[8].AddBranch(piccadillyPath1);
        lines[8].AddBranch(piccadillyPath2);
        lines[8].AddBranch(piccadillyPath3);

        lines[9] = new TubeLine("VICTORIA", "0098D4", 9);
        string[] victoriaPath = { "BRIXTON", "STOCKWELL", "VAUXHALL", "PIMLICO", "VICTORIA", "GREEN PARK", "OXFORD CIRCUS", "WARREN STREET", "EUSTON", "KINGS CROSS", "HIGHBURY N ISLINGTON", "FINSBURY PARK", "SEVEN SISTERS", "TOTTENHAM HALE", "BLACKHORSE ROAD", "WALTHOMSTOW CENTRAL" };
        lines[9].AddBranch(victoriaPath);

        lines[10] = new TubeLine("WATERLOO N CITY", "95CDBA", 10);
        string[] wineNcheesePath = { "WATERLOO", "BANK" };
        lines[10].AddBranch(wineNcheesePath);

        return lines;
    }

    void HandleWayfindingSolve()
    {
        pagesLocked = false;
        currentPage = 2;
        pageUpdate(2);
    }

    void CheckUnicorns()
    {
        var angelStations = new List<string> { "HOLBORN", "ANGEL", "GLOUCESTER ROAD" };

        if (angelStations.Contains(origin) && angelStations.Contains(destination))
        {
            angelUnicorn = true;
            angelStations.Remove(origin);
            angelStations.Remove(destination);

            angelUnicornSubmission = angelStations[0];
            return;
        }

        if (new string[] { "NEASDEN", "HAMMERSMITH", "NORTH GREENWICH" }.Contains(origin) && new string[] { "NEASDEN", "HAMMERSMITH", "NORTH GREENWICH" }.Contains(destination)) ikeaUnicorn = true;
    }

    // Catches unicorn-related inputs and updates pages as necessary. Returns true if a unicorn was successfully solved.
    bool CorrectUnicornInputs()
    {
        if (angelUnicorn && routeInputs[0] == angelUnicornSubmission && routeInputs[1] == angelUnicornSubmission && routeInputs[2] == angelUnicornSubmission)
        {
            SetAngelPages();
            tubecipherBackgroundNumber = 2;
            return true;
        }

        if (ikeaUnicorn && routeInputs[0] == "IKEA" && routeInputs[1] == "IKEA" && routeInputs[2] == "IKEA")
        {
            SetIkeaPages();
            tubecipherBackgroundNumber = 3;
            return true;
        }

        return false;
    }

    // Sets the pages for London Underground Cipher after Wayfinding step.
    void SetDefaultKuroPages()
    {
        TubeCipher.EncryptWord(linesTakenPathOne.Concat(linesTakenPathTwo).ToArray(), "JUDGING", Bomb); //TEMP: KEYWORD IS OBTAINED FROM NON-BINARY CIPHER.

        pageContents[1, 0] = routeInputs[0];
        pageContents[1, 1] = routeInputs[1];
        pageContents[1, 2] = routeInputs[2];

        pageContents[2, 0] = TubeCipher.EncryptedWord;
        pageContents[2, 1] = linesTakenPathOne[0].Name;
        pageContents[2, 2] = linesTakenPathOne[1].Name;

        pageContents[3, 0] = linesTakenPathTwo[0].Name;
        pageContents[3, 1] = linesTakenPathTwo[1].Name;
        pageContents[3, 2] = linesTakenPathTwo[2].Name;
    }

    // Sets the pages for London Underground Cipher if an Angel unicorn is dealt with correctly.
    void SetAngelPages()
    {
        pageContents[1, 0] = routeInputs[0];
        pageContents[1, 1] = routeInputs[1];
        pageContents[1, 2] = routeInputs[2];

        pageContents[2, 0] = "ANGEL";
        pageContents[2, 1] = "THANKS";
        pageContents[2, 2] = "YOU";

        pageContents[3, 0] = "KEYWORD";
        pageContents[3, 1] = "IS";
        pageContents[3, 2] = "KEYWORD";
    }

    // Sets the pages for London Underground Cipher is Ikea unicorn is dealt with correctly.
    void SetIkeaPages()
    {
        pageContents[1, 0] = routeInputs[0];
        pageContents[1, 1] = routeInputs[1];
        pageContents[1, 2] = routeInputs[2];

        pageContents[2, 0] = "DOCKSTA";
        pageContents[2, 1] = "KALLAX";
        pageContents[2, 2] = "EKTORP";

        pageContents[3, 0] = "KEYWORD";
        pageContents[3, 1] = "IS";
        pageContents[3, 2] = "KEYWORD";
    }

    #endregion


#pragma warning disable 414
    private readonly string TwitchHelpMessage = @"Use !{0} to do something.";
#pragma warning restore 414

    IEnumerator ProcessTwitchCommand(string Command)
    {
        yield return null;
    }

    IEnumerator TwitchHandleForcedSolve()
    {
        yield return null;
    }
}


// Represents the London Underground Cipher
static class TubeCipher
{
    public static string EncryptedWord;
    private static TubeLine.Path[] _paths;
    private static string _trainfairKey;
    private static char[,] _trainfairGrid = new char[5, 5];
    private static KMBombInfo Bomb;

    private static Dictionary<int, string> LineToShiftID = new Dictionary<int, string>()
    {
        {0, "C3"},
        {1, "R0"},
        {2, "R3"},
        {3, "C0"},
        {4, "C2"},  
        {5, "C4"},
        {6, "C1"},
        {7, "R4"},
        {8, "R1"},
        {9, "R2"},
        {10, "NONE"}
    };

    public static void EncryptWord(TubeLine.Path[] paths, string keyword, KMBombInfo bomb)
    {
        Bomb = bomb;
        _paths = paths;
        EncryptedWord = keyword;
        _trainfairKey = GenerateKey();
        GenerateGrid();

        EncryptedWord = ChooChooMotherfucker();

        PerformTubeLineTransposition();
    }

    // Trainfair stuff below this.


    // Converts a path to a key consisting of the first letter of each station name in that path.
    private static string ConvertToKey(params TubeLine.Path[] pathsToConvert)
    {
        string key = "";

        foreach (TubeLine.Path path in pathsToConvert)
        {
            foreach (string station in path.Stations)
            {
                key += station[0];
            }
        }

        return key;
    }

    // Generate the Trainfair key to be used for Trainfair Cipher.
    private static string GenerateKey()
    {
        string pathKey1 = ConvertToKey(_paths[0], _paths[1]);
        string pathKey2 = ConvertToKey(_paths[2], _paths[3], _paths[4]);

        if (EncryptedWord.Length % 2 == 0)
        {
            if (pathKey1.Length >= pathKey2.Length) return pathKey1;
            return pathKey2;
        }

        if (pathKey1.Length <= pathKey2.Length) return pathKey1;
        return pathKey2;
    }
    
    // Create a Trainfair grid out of the Trainfair key.
    private static void GenerateGrid()
    {
        Debug.Log("Something");
        string grid = "";

        foreach (char letter in _trainfairKey + "ABCDEFGHIKLMNOPQRSTUVWXYZ")
        {
            if (letter != 'j' && !grid.Contains(letter)) grid += letter;
        }

        for (int row = 0; row < 5; row++)
            for (int col = 0; col < 5; col++)
                _trainfairGrid[row, col] = grid[row * 5 + col];
    }

    // Return a pair of letters which are the result of performing Trainfair on the parameter letterPair.
    private static string DoTrainfairOn(string letterPair)
    {
        int[] position1;
        int[] position2;

        Debug.Log(letterPair);

        if (letterPair[0] == letterPair[1]) return letterPair; // Do not modify if both letters are the same.
        if (letterPair.Contains("J")) return letterPair; // Do not modify if either letter is J.

        position1 = GetGridPosition(letterPair[0]).ToArray();
        position2 = GetGridPosition(letterPair[1]).ToArray();

        if (position1[0] == position2[0]) return _trainfairGrid[position1[0], (position1[1] + 1) % 5].ToString() + _trainfairGrid[position2[0], (position2[1] + 1) % 5].ToString(); // Same row.

        if (position1[1] == position2[1]) return _trainfairGrid[(position1[0] + 1) % 5, position1[1]].ToString() + _trainfairGrid[(position2[0] + 1) % 5, position1[1]].ToString(); // Same column.

        return _trainfairGrid[position1[0], position2[1]].ToString() + _trainfairGrid[position2[0], position1[1]].ToString(); // Different rows and columns.
    }

    // Return an int[] containing the lineNumbers of the unused lines to be used for Trainfair grid shifting.
    private static int[] GetLinesForShifting()
    {
        var linesForShifting = new List<int>(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
        int initialLength;

        foreach (TubeLine.Path path in _paths)
        {
            linesForShifting.Remove(path.Line.LineNumber);
        }

        initialLength = linesForShifting.Count();

        if (linesForShifting.Count() >= EncryptedWord.Length - 1) return linesForShifting.GetRange(0, EncryptedWord.Length - 2).ToArray();

        while (linesForShifting.Count() < EncryptedWord.Length - 2) linesForShifting.Add(linesForShifting[linesForShifting.Count() - initialLength]);
        return linesForShifting.ToArray();
    }

    // Return an int[] containing the shift indices based on the alphanumeric positions of the serial number characters.
    private static int[] GetShiftIndices()
    {
        string serial = Bomb.GetSerialNumber().ToUpper();
        var shiftIndices = new List<int>();

        foreach (char character in serial)
        {
            if ("0123456789".Contains(character)) shiftIndices.Add(character - '0');
            else shiftIndices.Add("ABCDEFGHIJKLMNOPQRSTUVWXYZ".IndexOf(character) + 1);
        }

        if (shiftIndices.Count() >= EncryptedWord.Length - 1) return shiftIndices.GetRange(0, EncryptedWord.Length - 2).ToArray();

        while (shiftIndices.Count() < EncryptedWord.Length - 2) shiftIndices.Add(shiftIndices[shiftIndices.Count() - serial.Length]);
        return shiftIndices.ToArray();
    }

    // Applies Compacted Traincipher encryption to the Non-Binary Cipher keyword.
    private static string ChooChooMotherfucker()
    {
        int[] linesForShifting = GetLinesForShifting();
        int[] shiftIndices = GetShiftIndices();
        string chewedWord;
        int currentPos = 0;
        int totalShifts = shiftIndices.Count() - 1;

        PreShift(linesForShifting, shiftIndices);

        chewedWord = DoTrainfairOn(EncryptedWord.Substring(EncryptedWord.Length - 2));


        for (int i = EncryptedWord.Length - 3; i>=0; i--)
        {
            ShiftGrid(linesForShifting[totalShifts - currentPos], -shiftIndices[totalShifts - currentPos]); // This is undoing the PreShift() pair by pair because encrypted happens right-to-left.
            chewedWord = DoTrainfairOn(EncryptedWord[i].ToString() + chewedWord[0].ToString()) + chewedWord.Substring(1);
            currentPos++;
        }

        return chewedWord;
    }

    // Return a two-element array of int containing the position of a letter in the grid.
    private static int[] GetGridPosition(char letter)
    {
        for (int row = 0; row < 5; row++)
            for (int col = 0; col < 5; col++)
            {
                if (letter == _trainfairGrid[row, col])
                    return new int[] { row, col };
            }
        throw new InvalidOperationException("MATE WHAT R U DOING (CHARACTER NOT IN GRID).");
    }

    // Shifts the row/column corresponding to the lineNumber by the shiftIndex.
    private static void ShiftGrid(int lineNumber, int shiftIndex)
    {
        string shiftID = LineToShiftID[lineNumber];

        if (shiftID == "NONE") return;

        if (shiftID[0] == 'R') ShiftRow(shiftID[1] - '0', shiftIndex);
        else ShiftColumn(shiftID[1] - '0', shiftIndex);
    }

    // Shift the given column down by the given shifting index.
    private static void ShiftColumn(int columnNumber, int shiftIndex)
    {
        string columnContents = "";

        for (int i = 0; i < 5; i++)
        {
            columnContents += _trainfairGrid[i, columnNumber];
        }

        columnContents = CipherTools.ShiftRight(columnContents, shiftIndex);

        for (int i = 0; i < 5; i++)
        {
            _trainfairGrid[i, columnNumber] = columnContents[i];
        }
    }

    // Shift the given row right by the given shifting index.
    private static void ShiftRow(int rowNumber, int shiftIndex)
    {
        string rowContents = "";

        for (int i = 0; i < 5; i++)
        {
            rowContents += _trainfairGrid[rowNumber, i];
        }

        rowContents = CipherTools.ShiftRight(rowContents, shiftIndex);

        for (int i = 0; i < 5; i++)
        {
            _trainfairGrid[rowNumber, i] = rowContents[i];
        }
    }

    // Applies all the shifts to the grid so that the word can be encrypted in the correct order.
    private static void PreShift(int[] linesForShifting, int[] shiftIndices)
    {
        for (int i = 0; i<linesForShifting.Length; i++)
        {
            ShiftGrid(linesForShifting[i], shiftIndices[i]);
        }
    }


    // Transposition Stuff below this.
    private static void PerformTubeLineTransposition()
    { 
        string transpositionKey = GetTranspositionKey(_paths).Substring(0, EncryptedWord.Length);
        EncryptedWord = Transpose(EncryptedWord, transpositionKey);
    }

    // Apply Tube Line Transposition using transpositionKey to keyword
    private static string Transpose(string keyword, string transpositionKey)
    {
        var transpositionPositions = new List<int>();
        var encryptedLetters = new string[keyword.Length];

        foreach (char keyDigit in "0123456789ABCDEF")
        {
            foreach (int i in Enumerable.Range(0, keyword.Length))
            {
                if (transpositionKey[i] == keyDigit) transpositionPositions.Add(i);
            }
        }

        foreach (int i in Enumerable.Range(0, keyword.Length))
        {
            encryptedLetters[transpositionPositions[i]] = keyword[i].ToString();
        }

        return string.Join("", encryptedLetters);
    }

    // Create the transposition key from the lines taken in Wayfinding step.
    private static string GetTranspositionKey(TubeLine.Path[] paths)
    {
        string lineHexCodes = "";
        int shiftIndex = Math.Abs((paths[0].Stations.Length + paths[1].Stations.Length) - (paths[2].Stations.Length + paths[3].Stations.Length + paths[4].Stations.Length));
        string key1;
        string key2;

        for (int i = 0; i < 5; i++)
        {
            lineHexCodes += paths[i].Line.Colour;
        }

        lineHexCodes = CipherTools.ShiftRight(lineHexCodes, shiftIndex);
        key1 = (int.Parse(lineHexCodes.Substring(0, 6), System.Globalization.NumberStyles.HexNumber) + int.Parse(lineHexCodes.Substring(6, 6), System.Globalization.NumberStyles.HexNumber)).ToString("X6");
        key2 = (int.Parse(lineHexCodes.Substring(12, 6), System.Globalization.NumberStyles.HexNumber) + int.Parse(lineHexCodes.Substring(18, 6), System.Globalization.NumberStyles.HexNumber)
             + int.Parse(lineHexCodes.Substring(24, 6), System.Globalization.NumberStyles.HexNumber)).ToString("X6");

        if (IsEven(key1) == IsEven(key2)) return key1 + key2;
        return key2 + key1;
    }

    // Takes a string representing a hex value (hexString), and returns true if it is even and false otherwise.
    private static bool IsEven(string hexString)
    {
        if ("02468ACE".Contains(hexString[hexString.Length - 1])) return true;
        return false;
    }

}

static class CipherTools
{
    public static string ShiftLeft(string text, int shiftIndex)
    {
        shiftIndex = ((shiftIndex % text.Length) + text.Length) % text.Length;
        return text.Substring(shiftIndex) + text.Substring(0, shiftIndex);
    }

    public static string ShiftRight(string text, int shiftIndex)
    {
        shiftIndex = ((shiftIndex % text.Length) + text.Length) % text.Length;
        return text.Substring(text.Length - shiftIndex) + text.Substring(0, text.Length - shiftIndex);
    }
}

class TubeLine
{
    public string Name;
    public string Colour;
    public List<string> Stations = new List<string>();
    private readonly List<Branch> _branches = new List<Branch>();
    public float[] RGBValues = { 0, 0, 0 };
    public int LineNumber;

    public TubeLine(string lineName, string lineColour, int lineNumber)
    {
        LineNumber = lineNumber;
        Name = lineName;
        Colour = lineColour;
        SetRGBValues();
    }

    private void SetRGBValues()
    {

        if (Colour == "000000")
        {
            RGBValues[0] = 1;
            RGBValues[1] = 1;
            RGBValues[2] = 1;
        }
        else
        {
            RGBValues[0] = (float)int.Parse(Colour.Substring(0, 2), System.Globalization.NumberStyles.HexNumber) / 255;
            RGBValues[1] = (float)int.Parse(Colour.Substring(2, 2), System.Globalization.NumberStyles.HexNumber) / 255;
            RGBValues[2] = (float)int.Parse(Colour.Substring(4, 2), System.Globalization.NumberStyles.HexNumber) / 255;
        }
    }

    public void AddBranch(string[] stationsList, string branchIdentifier = "")
    {
        _branches.Add(new Branch(stationsList, branchIdentifier));
        Stations.AddRange(stationsList);
        Stations = Stations.Distinct().ToList();
    }

    private class Branch
    {
        // private readonly string[] _stations;
        public string[] _stations;
        public string LeftEndPoint;
        public string RightEndPoint;
        public string Name;

        public Branch(string[] stationsList, string branchName)
        {
            _stations = stationsList;
            LeftEndPoint = stationsList[0];
            RightEndPoint = stationsList[stationsList.Count() - 1];
            Name = branchName;
        }

        public bool Contains(string station)
        {
            return _stations.Contains(station);
        }

        public List<string> GetPath(string startStation, string endStation, bool reverse)
        // Return a string containing the path from startStation to endStation.
        // reverse -> if true, then the branch will be processed in the right-to-left direction, otherwise it will be searched from left-to-right.
        {
            int position = Array.IndexOf(_stations, startStation);
            var i = reverse ? -1 : 1;
            string currentStation;
            var path = new List<string>();

            do
            {
                currentStation = _stations[position];
                path.Add(currentStation);
                position += i;
            } while (currentStation != endStation && position >= 0 && position < _stations.Length);

            return path;
        }
    }

    public class PathFinder
    {
        private readonly List<List<string>> _paths = new List<List<string>>();
        public readonly TubeLine _line;

        public PathFinder(TubeLine line, string start, string end)
        {
            _line = line;

            FindPaths(start, end, new List<string>(), false);
            FindPaths(start, end, new List<string>(), true);
        }

        private void FindPaths(string start, string end, List<string> pathSoFar, bool reverse)
        // Find all valid paths from start to end.
        // reverse -> specifies whether the paths are searched right-to-left or left-to-right.
        {
            List<string> path;

            foreach (Branch branch in _line._branches)
            {
                path = new List<string>(pathSoFar);

                if (branch.Contains(start))
                {
                    if (branch.RightEndPoint != start && !reverse)
                    {
                        CheckForEndStation(start, end, reverse, path, branch);
                    }

                    if (branch.LeftEndPoint != start && reverse)
                    {
                        CheckForEndStation(start, end, reverse, path, branch);
                    }
                }
            }
        }

        private void CheckForEndStation(string start, string end, bool reverse, List<string> path, Branch branch)
        {
            string endOfPathSoFar;
            var flag = false;
            path.AddRange(branch.GetPath(start, end, reverse));

            if (path.Contains(end))
            {
                foreach (List<string> _path in _paths)
                {
                    if (AreTheSameFuckingList(_path, path)) flag = true;
                }
                if (!flag) _paths.Add(path);
            }
            else
            {
                endOfPathSoFar = path[path.Count() - 1];
                path.Remove(endOfPathSoFar);
                FindPaths(endOfPathSoFar, end, path, reverse);
            }
        }

        private bool AreTheSameFuckingList(List<string> list1, List<string> list2)
        {
            if (list1.Count() != list2.Count()) return false;

            for (int i = 0; i < list1.Count(); i++)
            {
                if (list1[i] != list2[i]) return false;
            }

            return true;
        }

        public bool HasPath()
        {

            //foreach (List<string> path in _paths)
            //{
            //    Debug.Log(string.Join(" ", path.ToArray()));
            //}
            if (_paths.Count == 0)
            {
                return false;
            }
            return true;
        }

        public Path ProducePath()
        {
            int i = Rnd.Range(0, _paths.Count());
            var p = new Path(_line, _paths[i].ToArray());
            return p;
        }
    }

    public class Path
    {
        public TubeLine Line;
        public string Name;
        public string[] Stations;
        public string id;
        private string[] _endPoints = new string[2];

        public Path(TubeLine line, string[] pathStations)
        {
            Line = line;
            Name = line.Name;
            id = line.Name;
            Stations = pathStations;
            _endPoints[0] = Stations[0];
            _endPoints[1] = Stations[Stations.Length - 1];

            if (Name == "NORTHERN") CheckNorthernLineExceptions();
            if (Name == "CIRCLE") CheckCircleLineDirection();
        }

        private void CheckNorthernLineExceptions()
        {
            if (_endPoints.Contains("EUSTON") && Stations.Contains("CAMDEN TOWN"))
            {
                if (Stations.Contains("MORNINGTON CRESCENT")) Name = "NORTHERN CC BRANCH";
                else Name = "NORTHERN BANK BRANCH";
            }
            else if ((_endPoints.Contains("EUSTON") || Stations.Contains("CAMDEN TOWN")) && (Stations.Contains("KENNINGTON") && !Stations.Contains("NINE ELMS")))
            {
                if (Stations.Contains("CHARING CROSS")) Name = "NORTHERN CC BRANCH";
                else Name = "NORTHERN BANK BRANCH";
            }
        }

        private void CheckCircleLineDirection()
        {
            if (_endPoints.Contains("PADDINGTON") || _endPoints.Contains("EDGWARE ROAD"))
            {
                if (Stations.Contains("BAYSWATER")) Name = "CIRCLE VIA BAYSWATER";
                else if (Stations.Contains("BAKER STREET")) Name = "CIRCLE VIA BAKER ST";
            }
        }
    }
}